<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="title:Tinker原理解析  [TOC] Tinker原理解析补丁包生成原理Tinker打补丁主要为两个步骤：1.通过执行gradke task tinkerPatchDebug(Release)生成补丁包。2.通过tinkerInstaller将补丁包进行合成。 我们先来分析第一步：tinkerPatchDebug task包括两个步骤，1.执行debug生成修复代码之后的apk。2.执行">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://youuupeng.github.io/2019/02/20/Tinker原理解析/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title:Tinker原理解析  [TOC] Tinker原理解析补丁包生成原理Tinker打补丁主要为两个步骤：1.通过执行gradke task tinkerPatchDebug(Release)生成补丁包。2.通过tinkerInstaller将补丁包进行合成。 我们先来分析第一步：tinkerPatchDebug task包括两个步骤，1.执行debug生成修复代码之后的apk。2.执行">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/tinkerPatch相关流程.png">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/生成class文件.jpg">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/生成dex出错.jpg">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/java%20class%20dex文件.jpg">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/dex文件结构(1">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/dex文件结构(2">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/dex文件结构.jpg">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/dex大致结构.jpg">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/dex_header字段含义.jpg">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/dex具体结构.jpg">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/dex_map_list结构.jpg">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/tinker打补丁包基础流程.png">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/Hello.dex结构.jpg">
<meta property="og:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/World.dex结构.jpg">
<meta property="og:updated_time" content="2019-03-02T06:37:37.903Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="title:Tinker原理解析  [TOC] Tinker原理解析补丁包生成原理Tinker打补丁主要为两个步骤：1.通过执行gradke task tinkerPatchDebug(Release)生成补丁包。2.通过tinkerInstaller将补丁包进行合成。 我们先来分析第一步：tinkerPatchDebug task包括两个步骤，1.执行debug生成修复代码之后的apk。2.执行">
<meta name="twitter:image" content="c:/Users/peyo/Desktop/图片资料/tinker接入实践/tinker原理解析/tinkerPatch相关流程.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://youuupeng.github.io/2019/02/20/Tinker原理解析/">





  <title> | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/android/hotfix/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://youuupeng.github.io/2019/02/20/Tinker原理解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youpeng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T16:15:56+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>title:Tinker原理解析</p>
<hr>
<p>[TOC]</p>
<h4 id="Tinker原理解析"><a href="#Tinker原理解析" class="headerlink" title="Tinker原理解析"></a>Tinker原理解析</h4><h5 id="补丁包生成原理"><a href="#补丁包生成原理" class="headerlink" title="补丁包生成原理"></a>补丁包生成原理</h5><p>Tinker打补丁主要为两个步骤：1.通过执行gradke task tinkerPatchDebug(Release)生成补丁包。2.通过tinkerInstaller将补丁包进行合成。</p>
<p>我们先来分析第一步：tinkerPatchDebug task包括两个步骤，1.执行debug生成修复代码之后的apk。2.执行tinkerPatch生成补丁包。</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\tinkerPatch相关流程.png" alt="tinkerPatch相关流程"></p>
<p>1-7：构建gradle tinkerPatch task</p>
<p>8-9：将新旧apk对比构建补丁包：将两个apk的内容读取到流中，对比是否有新添加的class文件</p>
<p>10-15：将apk以流的形式读取，进行对比</p>
<p>16-19：patch补丁包生成</p>
<p>20-23：将patch补丁和原来的apk合成新的修复过后的apk</p>
<p>可以看出，这里的核心在于16-23，就是<strong>如何生成补丁包</strong>和<strong>进行补丁包的修复</strong>。下面我会主要从这两两个角度进行原理剖析。</p>
<p>在具体讲tinker是如何实现这部分模块之前先介绍一下准备知识。</p>
<h5 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h5><h6 id="生成dex"><a href="#生成dex" class="headerlink" title="生成dex"></a>生成dex</h6><p>编写一个Hello.java文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;hello dex!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成Hello.class文件：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\生成class文件.jpg" alt="生成class文件"></p>
<p>然后把java文件和class文件放到sdk-&gt;build-tools-&gt;23.0.1中，生成dex文件：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\生成dex出错.jpg" alt="生成dex出错"></p>
<p>会发现放在23.0.1下边出错，我把它放到28.0.2下边就正常了，可能低版本有点问题。最后会有3个文件：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\java class dex文件.jpg" alt="java class dex文件"></p>
<p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="noopener">dex的内部结构</a>如下</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex文件结构(1" alt="dex文件结构(1)">.jpg)</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex文件结构(2" alt="dex文件结构(2)">.jpg)</p>
<p>下边这张图更直观一点：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex文件结构.jpg" alt="dex文件结构"></p>
<p>dex是使用LEB128编码的，用<a href="http://www.sweetscape.com/010editor/" target="_blank" rel="noopener">010Editor</a>可以看dex文件。可以看到010Editor解析出来的数据基本跟dex文件结构对应，link_data在010Editor中表示为map_list</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex大致结构.jpg" alt="dex大致结构"></p>
<p>这里我们主要对dex_header和map_list做大致的分析：</p>
<p><strong>dex_header</strong>：</p>
<p>magic：魔法值DEX_FILE_MAGIC。用来标识是dex文件，java的魔法值是CAFFEEBABE。</p>
<p>其他相关字段含义：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex_header字段含义.jpg" alt="dex_header字段含义"></p>
<p>注意，从下面的图中可以看到，dex_header中的string_ids_size,string_ids_off这种成对出现的分别代表大小和偏移量，对应着下面出现的其他表的数据。</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex具体结构.jpg" alt="dex具体结构"></p>
<p><strong>dex_map_list</strong></p>
<p>其对应的结构如下：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex_map_list结构.jpg" alt="dex_map_list结构"></p>
<p>每个map_item_list包含一个enum表示类型,一个ushort未使用的成员,一个uint表示当前类型的个数，一个uint表示当前类型偏移量。</p>
<p>首先是TYPE_HEADER_ITEM类型，包含1个header（size=1），偏移量为0</p>
<p>然后是TYPE_STRING_ID_ITEM,包含14个string_id_item(size=14),偏移量为112.跟前面dex_header中的数据是一样的。</p>
<p>以此类推。通过map_list，可以将一个完整的dex文件划分成固定的区域，且知道每个区域的开始，以及该区域对应的数据格式的个数。</p>
<h5 id="一种可能的tinkerPatch算法"><a href="#一种可能的tinkerPatch算法" class="headerlink" title="一种可能的tinkerPatch算法"></a>一种可能的tinkerPatch算法</h5><p>在tinker中，我们是生成了新旧apk，其内部是通过对比差异来得出一个差量包，其对比的文件就是dex为单位。</p>
<p>在对比前，有两个dex:1.old dex.2.new dex。对比生成一个patch文件，然后patch文件可以和old dex通过算法合成一个新的dex。</p>
<p>那么patch + old dex-&gt;new dex的步骤就包括几个部分：</p>
<p>1.header不作处理，因为可以根据其他数据生成；</p>
<p>2.map list。获取各个区域的offset偏移值</p>
<p>3.知道了各个区域的offset后，在生成new dex的时候，定位各个区域的开始和结束为止，往各个区域写数据即可。</p>
<p>假设针对一个区域的diff，假设有个string 区域，用于存储字符串：</p>
<p>old dex区域的字符串:Hello World</p>
<p>new dex区域的字符串：Hello dex</p>
<p>可以看出该区域，我们删除了World，增加了dex，那么patch中针对该区域可以作如下记录：“del World,add dex”（实际转换成对应的编码）那么在patch的时候可以很容易的计算出new dex最后的结果为：Hello dex。这样就是一个大致的diff和patch算法。</p>
<p>tinker就是基于上面这样的思想来实现的，当然实际情况比这个要复杂的多。</p>
<h5 id="生成差分包的原理"><a href="#生成差分包的原理" class="headerlink" title="生成差分包的原理"></a>生成差分包的原理</h5><p>从前面的流程图可以看到补丁包的生成过程是在16-19。</p>
<p>15的代码如下：</p>
<p>以下代码为了方便理解都有一定的删减。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void diffDexPairAndFillRelatedInfo(File oldDexFile, File newDexFile, RelatedInfo relatedInfo) &#123;</span><br><span class="line">    DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldDexFile, newDexFile);</span><br><span class="line">    dexPatchGen.executeAndSaveTo(dexDiffOut);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里有两个步骤。</p>
<p>1：DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldDexFile, newDexFile); </p>
<p>2：dexPatchGen.executeAndSaveTo(dexDiffOut);</p>
<p>接下来我们先看1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class DexPatchGenerator &#123;</span><br><span class="line">	public DexPatchGenerator(File oldDexFile, File newDexFile) throws IOException &#123;</span><br><span class="line">   		 this(new Dex(oldDexFile), new Dex(newDexFile));</span><br><span class="line">	&#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final class Dex &#123;</span><br><span class="line">	public Dex(File file) throws IOException &#123;</span><br><span class="line">        loadFrom(inputStream, (int) entry.getSize());</span><br><span class="line">    ｝  </span><br><span class="line">    private void loadFrom(InputStream in, int initSize) throws IOException &#123;</span><br><span class="line">        byte[] rawData = FileUtils.readStream(in, initSize);</span><br><span class="line">        this.data = ByteBuffer.wrap(rawData);</span><br><span class="line">        this.data.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        this.tableOfContents.readFrom(this);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final class TableOfContents &#123;</span><br><span class="line">	public void readFrom(Dex dex) throws IOException &#123;</span><br><span class="line">        readHeader(dex.openSection(header));</span><br><span class="line">        readMap(dex.openSection(mapList.off));</span><br><span class="line">        computeSizesFromOffsets();</span><br><span class="line">    &#125;</span><br><span class="line">    //这里就是将dex中的字段读取出来保存起来</span><br><span class="line">    private void readHeader(Dex.Section headerIn) throws UnsupportedEncodingException &#123;</span><br><span class="line">        byte[] magic = headerIn.readByteArray(8);</span><br><span class="line">        checksum = headerIn.readInt();</span><br><span class="line">        signature = headerIn.readByteArray(20);</span><br><span class="line">        fileSize = headerIn.readInt();</span><br><span class="line">        int headerSize = headerIn.readInt();</span><br><span class="line">        int endianTag = headerIn.readInt();</span><br><span class="line">        linkSize = headerIn.readInt();</span><br><span class="line">        linkOff = headerIn.readInt();</span><br><span class="line">        mapList.off = headerIn.readInt();</span><br><span class="line">      ｝</span><br><span class="line">      private void readMap(Dex.Section in) throws IOException &#123;</span><br><span class="line">        int mapSize = in.readInt();</span><br><span class="line">        Section previous = null;</span><br><span class="line">        for (int i = 0; i &lt; mapSize; i++) &#123;</span><br><span class="line">            short type = in.readShort();</span><br><span class="line">            in.readShort(); // unused</span><br><span class="line">            Section section = getSection(type);</span><br><span class="line">            int size = in.readInt();</span><br><span class="line">            int offset = in.readInt();</span><br><span class="line">            section.size = size;</span><br><span class="line">            section.off = offset;</span><br><span class="line">            previous = section;</span><br><span class="line">        &#125;</span><br><span class="line">        header.off = 0;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里的核心就在于readHeader和readMap，在这两个步骤完成之后就完成了dex文件到dex对象的初始化。</p>
<p>在读取header的时候，已经读取了除了map list区域的offset,并存储在mapList.off中。所以readMap中传入的是这个参数，开始读取map list的数据。首先读取的是map_list_item的个数，然后在for循环中便利读取每个map_list_item的实际数据。</p>
<p>依次读取的数据为：type,unused,size,offset，这些都是跟我们前面讲的map_list_item对应的，在Tinker中对应的对象为TableContents.Section对象。</p>
<p>至此，拿到了两个Dex对象，接下来开始做diff操作。</p>
<p>步骤1我们已经分析完了，接下来看步骤2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class DexPatchGenerator &#123;</span><br><span class="line">	public DexPatchGenerator(Dex oldDex, Dex newDex) &#123;</span><br><span class="line">        this.oldDex = oldDex;</span><br><span class="line">        this.newDex = newDex;</span><br><span class="line">        //这里初始化15个算法，每个算法代表dex的每个字段，算法的作用就是我们之前说的那种算法，用来计算增加了哪些，需要删除哪些</span><br><span class="line">        this.stringDataSectionDiffAlg = new StringDataSectionDiffAlgorithm</span><br><span class="line">        this.typeIdSectionDiffAlg = new TypeIdSectionDiffAlgorithm</span><br><span class="line">        this.protoIdSectionDiffAlg = new ProtoIdSectionDiffAlgorithm</span><br><span class="line">        this.fieldIdSectionDiffAlg = new FieldIdSectionDiffAlgorithm</span><br><span class="line">        this.methodIdSectionDiffAlg = new MethodIdSectionDiffAlgorithm</span><br><span class="line">        ···（省略）</span><br><span class="line">        this.codeSectionDiffAlg = new CodeSectionDiffAlgorithm(</span><br><span class="line">                oldDex, newDex,</span><br><span class="line">                oldToNewIndexMap,</span><br><span class="line">                oldToPatchedIndexMap,</span><br><span class="line">                newToPatchedIndexMap,</span><br><span class="line">                selfIndexMapForSkip</span><br><span class="line">        );</span><br><span class="line">    ｝</span><br><span class="line">    public void executeAndSaveTo(File file) throws IOException &#123;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        os = new BufferedOutputStream(new FileOutputStream(file));</span><br><span class="line">            executeAndSaveTo(os);</span><br><span class="line">    &#125;</span><br><span class="line">    public void executeAndSaveTo(OutputStream out) throws IOException &#123;</span><br><span class="line">    //1.执行execute方法</span><br><span class="line">    	this.stringDataSectionDiffAlg.execute();</span><br><span class="line">         //2.执行simulatePatchOperation方法</span><br><span class="line">         this.stringDataSectionDiffAlg.simulatePatchOperation(this.patchedStringDataItemsOffset);</span><br><span class="line"></span><br><span class="line">        this.typeIdSectionDiffAlg.execute();</span><br><span class="line">        this.typeIdSectionDiffAlg.simulatePatchOperation(this.patchedTypeIdsOffset);</span><br><span class="line">        this.typeListSectionDiffAlg.execute();</span><br><span class="line">this.typeListSectionDiffAlg.simulatePatchOperation(this.patchedTypeListsOffset);</span><br><span class="line">	...</span><br><span class="line">		</span><br><span class="line">		// Finally, write results to patch file.</span><br><span class="line">        writeResultToStream(out);</span><br><span class="line">    ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里初始化每个算法之后主要执行3个操作，一个是execute方法，另一个是simulatePatchOperation方法，最后是执行writeResultToStream方法。这里先看execute方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public abstract class DexSectionDiffAlgorithm&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line">	public void execute() &#123;</span><br><span class="line">		this.patchOperationList.clear();</span><br><span class="line">		//1.拿到oldDex和newDex的itemList，进行调整排序</span><br><span class="line">        this.adjustedOldIndexedItemsWithOrigOrder = collectSectionItems(this.oldDex, true);</span><br><span class="line">        this.oldItemCount = this.adjustedOldIndexedItemsWithOrigOrder.length;</span><br><span class="line"></span><br><span class="line">        AbstractMap.SimpleEntry&lt;Integer, T&gt;[] adjustedOldIndexedItems = new AbstractMap.SimpleEntry[this.oldItemCount];</span><br><span class="line">        System.arraycopy(this.adjustedOldIndexedItemsWithOrigOrder, 0, adjustedOldIndexedItems, 0, this.oldItemCount);</span><br><span class="line">        Arrays.sort(adjustedOldIndexedItems, this.comparatorForItemDiff);</span><br><span class="line"></span><br><span class="line">        AbstractMap.SimpleEntry&lt;Integer, T&gt;[] adjustedNewIndexedItems = collectSectionItems(this.newDex, false);</span><br><span class="line">        this.newItemCount = adjustedNewIndexedItems.length;</span><br><span class="line">        Arrays.sort(adjustedNewIndexedItems, this.comparatorForItemDiff);</span><br><span class="line"></span><br><span class="line">        int oldCursor = 0;</span><br><span class="line">        int newCursor = 0;</span><br><span class="line">        //2.遍历，对比，收集patch操作</span><br><span class="line">        while (oldCursor &lt; this.oldItemCount || newCursor &lt; this.newItemCount) &#123;</span><br><span class="line">            if (oldCursor &gt;= this.oldItemCount) &#123;</span><br><span class="line">                // rest item are all newItem.</span><br><span class="line">                while (newCursor &lt; this.newItemCount) &#123;</span><br><span class="line">                //剩下的都是newIten，做ADD操作</span><br><span class="line">                    AbstractMap.SimpleEntry&lt;Integer, T&gt; newIndexedItem = adjustedNewIndexedItems[newCursor++];</span><br><span class="line">                    this.patchOperationList.add(new PatchOperation&lt;&gt;(PatchOperation.OP_ADD, newIndexedItem.getKey(), newIndexedItem.getValue()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else</span><br><span class="line">            if (newCursor &gt;= newItemCount) &#123;</span><br><span class="line">                // rest item are all oldItem.</span><br><span class="line">                while (oldCursor &lt; oldItemCount) &#123;</span><br><span class="line">                //剩下的都是oldItem，做DEL操作</span><br><span class="line">                    AbstractMap.SimpleEntry&lt;Integer, T&gt; oldIndexedItem = adjustedOldIndexedItems[oldCursor++];</span><br><span class="line">                    int deletedIndex = oldIndexedItem.getKey();</span><br><span class="line">                    int deletedOffset = getItemOffsetOrIndex(deletedIndex, oldIndexedItem.getValue());</span><br><span class="line">                    this.patchOperationList.add(new PatchOperation&lt;T&gt;(PatchOperation.OP_DEL, deletedIndex));</span><br><span class="line">                    markDeletedIndexOrOffset(this.oldToPatchedIndexMap, deletedIndex, deletedOffset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                AbstractMap.SimpleEntry&lt;Integer, T&gt; oldIndexedItem = adjustedOldIndexedItems[oldCursor];</span><br><span class="line">                AbstractMap.SimpleEntry&lt;Integer, T&gt; newIndexedItem = adjustedNewIndexedItems[newCursor];</span><br><span class="line">                int cmpRes = oldIndexedItem.getValue().compareTo(newIndexedItem.getValue());</span><br><span class="line">                if (cmpRes &lt; 0) &#123;</span><br><span class="line">                    int deletedIndex = oldIndexedItem.getKey();</span><br><span class="line">                    int deletedOffset = getItemOffsetOrIndex(deletedIndex, oldIndexedItem.getValue());</span><br><span class="line">                    this.patchOperationList.add(new PatchOperation&lt;T&gt;(PatchOperation.OP_DEL, deletedIndex));</span><br><span class="line">                    markDeletedIndexOrOffset(this.oldToPatchedIndexMap, deletedIndex, deletedOffset);</span><br><span class="line">                    ++oldCursor;</span><br><span class="line">                &#125; else</span><br><span class="line">                if (cmpRes &gt; 0) &#123;</span><br><span class="line">                    this.patchOperationList.add(new PatchOperation&lt;&gt;(PatchOperation.OP_ADD, newIndexedItem.getKey(), newIndexedItem.getValue()));</span><br><span class="line">                    ++newCursor;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int oldIndex = oldIndexedItem.getKey();</span><br><span class="line">                    int newIndex = newIndexedItem.getKey();</span><br><span class="line">                    int oldOffset = getItemOffsetOrIndex(oldIndexedItem.getKey(), oldIndexedItem.getValue());</span><br><span class="line">                    int newOffset = getItemOffsetOrIndex(newIndexedItem.getKey(), newIndexedItem.getValue());</span><br><span class="line"></span><br><span class="line">                    if (oldIndex != newIndex) &#123;</span><br><span class="line">                        this.oldIndexToNewIndexMap.put(oldIndex, newIndex);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (oldOffset != newOffset) &#123;</span><br><span class="line">                        this.oldOffsetToNewOffsetMap.put(oldOffset, newOffset);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ++oldCursor;</span><br><span class="line">                    ++newCursor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边首先拿到oldDex和newDex做调整，排序。然后开始遍历获取oldItem和newItem，对比其value:</p>
<p>如果&lt;0,则认为该old item被删除，记录为PatchOperation.OP_DEL,并将该oldItem index记录到PatchOperation对象，加入到patchOperationList中。</p>
<p>如果&gt;0,则认为该newItem是新增的，记录为PatchOperation.OP_ADD,并记录该newItem index和value到PatchOperation对象，加入到patchOperationList中。</p>
<p>如果=0，不会生成PatchOperation。</p>
<p>（这里看注释是&lt;0则删除，&gt;0是增加，但是是为什么啊？）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public void execute() &#123;</span><br><span class="line">	// So far all diff works are done. Then we perform some optimize works.</span><br><span class="line">        // detail: &#123;OP_DEL idx&#125; followed by &#123;OP_ADD the_same_idx newItem&#125;</span><br><span class="line">        // will be replaced by &#123;OP_REPLACE idx newItem&#125;</span><br><span class="line">        Collections.sort(this.patchOperationList, comparatorForPatchOperationOpt);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;PatchOperation&lt;T&gt;&gt; patchOperationIt = this.patchOperationList.iterator();</span><br><span class="line">        PatchOperation&lt;T&gt; prevPatchOperation = null;</span><br><span class="line">        while (patchOperationIt.hasNext()) &#123;</span><br><span class="line">            PatchOperation&lt;T&gt; patchOperation = patchOperationIt.next();</span><br><span class="line">            if (prevPatchOperation != null</span><br><span class="line">                &amp;&amp; prevPatchOperation.op == PatchOperation.OP_DEL</span><br><span class="line">                &amp;&amp; patchOperation.op == PatchOperation.OP_ADD</span><br><span class="line">            ) &#123;</span><br><span class="line">                if (prevPatchOperation.index == patchOperation.index) &#123;</span><br><span class="line">                    prevPatchOperation.op = PatchOperation.OP_REPLACE;</span><br><span class="line">                    prevPatchOperation.newItem = patchOperation.newItem;</span><br><span class="line">                    patchOperationIt.remove();</span><br><span class="line">                    prevPatchOperation = null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    prevPatchOperation = patchOperation;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prevPatchOperation = patchOperation;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finally we record some information for the final calculations.</span><br><span class="line">        patchOperationIt = this.patchOperationList.iterator();</span><br><span class="line">        while (patchOperationIt.hasNext()) &#123;</span><br><span class="line">            PatchOperation&lt;T&gt; patchOperation = patchOperationIt.next();</span><br><span class="line">            switch (patchOperation.op) &#123;</span><br><span class="line">                case PatchOperation.OP_DEL: &#123;</span><br><span class="line">                    indexToDelOperationMap.put(patchOperation.index, patchOperation);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case PatchOperation.OP_ADD: &#123;</span><br><span class="line">                    indexToAddOperationMap.put(patchOperation.index, patchOperation);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case PatchOperation.OP_REPLACE: &#123;</span><br><span class="line">                    indexToReplaceOperationMap.put(patchOperation.index, patchOperation);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面得到了一个patchOperationList对象之后，先对其进行排序。</p>
<p>然后执行一些优化操作，同一个index的item的OP_DEL操作后边紧跟着OP_ADD操作会被替换成OP_REPLACE。</p>
<p>然后最后生成3个Map:indexToDelOperationMap,indexToAddOperationMap,indexToReplaceOperationMap.</p>
<p>至此，完成了需要删除，添加，替换的item收集。</p>
<p>接着看simulatePatchOperation方法:</p>
<p>参数传入的偏移量为data区域的偏移量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public void simulatePatchOperation(int baseOffset) &#123;</span><br><span class="line">    boolean isNeedToMakeAlign = getTocSection(this.oldDex).isElementFourByteAligned;</span><br><span class="line">    int oldIndex = 0;</span><br><span class="line">    int patchedIndex = 0;</span><br><span class="line">    int patchedOffset = baseOffset;</span><br><span class="line">    while (oldIndex &lt; this.oldItemCount || patchedIndex &lt; this.newItemCount) &#123;</span><br><span class="line">        if (this.indexToAddOperationMap.containsKey(patchedIndex)) &#123;</span><br><span class="line">            PatchOperation&lt;T&gt; patchOperation = this.indexToAddOperationMap.get(patchedIndex);</span><br><span class="line">            if (isNeedToMakeAlign) &#123;</span><br><span class="line">                patchedOffset = SizeOf.roundToTimesOfFour(patchedOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            T newItem = patchOperation.newItem;</span><br><span class="line">            int itemSize = getItemSize(newItem);</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">            patchedOffset += itemSize;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (this.indexToReplaceOperationMap.containsKey(patchedIndex)) &#123;</span><br><span class="line">            PatchOperation&lt;T&gt; patchOperation = this.indexToReplaceOperationMap.get(patchedIndex);</span><br><span class="line">            T newItem = patchOperation.newItem;</span><br><span class="line">            int itemSize = getItemSize(newItem);</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">            patchedOffset += itemSize;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (this.indexToDelOperationMap.containsKey(oldIndex)) &#123;</span><br><span class="line">            ++oldIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (this.indexToReplaceOperationMap.containsKey(oldIndex)) &#123;</span><br><span class="line">            ++oldIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (oldIndex &lt; this.oldItemCount) &#123;</span><br><span class="line">            T oldItem = this.adjustedOldIndexedItemsWithOrigOrder[oldIndex].getValue();</span><br><span class="line">            int itemSize = getItemSize(oldItem);</span><br><span class="line"></span><br><span class="line">            int oldOffset = getItemOffsetOrIndex(oldIndex, oldItem);</span><br><span class="line">            int newIndex = oldIndex;</span><br><span class="line">            if (this.oldIndexToNewIndexMap.containsKey(oldIndex)) &#123;</span><br><span class="line">                newIndex = this.oldIndexToNewIndexMap.get(oldIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int newOffset = oldOffset;</span><br><span class="line">            if (this.oldOffsetToNewOffsetMap.containsKey(oldOffset)) &#123;</span><br><span class="line">                newOffset = this.oldOffsetToNewOffsetMap.get(oldOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            ++oldIndex;</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">            patchedOffset += itemSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.patchedSectionSize = SizeOf.roundToTimesOfFour(patchedOffset - baseOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里遍历oldIndex和patchIndex，分别在indexToAddOperationMap，indexToReplaceOperationMap，indexToDelOperationMap中查找。</p>
<p>最后生成patchedSectionSize，由patchedOffset - baseOffset计算得到。</p>
<p>这里在3个地方会执行patchedOffset += itemSize;</p>
<p>分别是if (this.indexToAddOperationMap.containsKey(patchedIndex))，if (this.indexToReplaceOperationMap.containsKey(patchedIndex))，if (oldIndex &lt; this.oldItemCount)从这几个判断条件可以看出，首先patchedSectionSize对应newDex的这个区域的size，所以，需要ADD的itemIndex,需要被替代的itemIndex，以及OLD ITEMS中没有被删除和替代的item，这三个加起来就是newIndex的itemList.</p>
<p>经过上面两个操作，得到PatchOperationList和对应区域的sectionSize，执行完所有的算法，就会得到针对每个算法的PatchOperationList和每个区域的sectionSize;每个区域的sectionSize再根据每个区域对应的字节单位长度计算得到每个区域的offset。</p>
<p>这里看最后一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private void writeResultToStream(OutputStream os) throws IOException &#123;</span><br><span class="line">    DexDataBuffer buffer = new DexDataBuffer();</span><br><span class="line">    buffer.write(DexPatchFile.MAGIC);</span><br><span class="line">    buffer.writeShort(DexPatchFile.CURRENT_VERSION);</span><br><span class="line">    buffer.writeInt(this.patchedDexSize);</span><br><span class="line">    // we will return here to write firstChunkOffset later.</span><br><span class="line">    int posOfFirstChunkOffsetField = buffer.position();</span><br><span class="line">    buffer.writeInt(0);</span><br><span class="line">    buffer.writeInt(this.patchedStringIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedTypeIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedProtoIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedFieldIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedMethodIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedClassDefsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedMapListOffset);</span><br><span class="line">    buffer.writeInt(this.patchedTypeListsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedAnnotationSetRefListItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedAnnotationSetItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedClassDataItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedCodeItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedStringDataItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedDebugInfoItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedAnnotationItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedEncodedArrayItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedAnnotationsDirectoryItemsOffset);</span><br><span class="line">    buffer.write(this.oldDex.computeSignature(false));</span><br><span class="line">    int firstChunkOffset = buffer.position();</span><br><span class="line">    buffer.position(posOfFirstChunkOffsetField);</span><br><span class="line">    buffer.writeInt(firstChunkOffset);</span><br><span class="line">    buffer.position(firstChunkOffset);</span><br><span class="line"></span><br><span class="line">    writePatchOperations(buffer, this.stringDataSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.typeIdSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.typeListSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.protoIdSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.fieldIdSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.methodIdSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.annotationSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.annotationSetSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.annotationSetRefListSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.annotationsDirectorySectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.debugInfoSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.codeSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.classDataSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.encodedArraySectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.classDefSectionDiffAlg.getPatchOperationList());</span><br><span class="line"></span><br><span class="line">    byte[] bufferData = buffer.array();</span><br><span class="line">    os.write(bufferData);</span><br><span class="line">    os.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要写入dex中的header的相关字段，然后写入所有的跟maplist各个区域相关的offset。然后调用各个区域对应算法写入信息，最后生成patch文件。这里以stringDataSectionDiffAlg为例，看下其源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T extends Comparable&lt;T&gt;&gt; void writePatchOperations(</span><br><span class="line">        DexDataBuffer buffer, List&lt;PatchOperation&lt;T&gt;&gt; patchOperationList</span><br><span class="line">) &#123;</span><br><span class="line">    List&lt;Integer&gt; delOpIndexList = new ArrayList&lt;&gt;(patchOperationList.size());</span><br><span class="line">    List&lt;Integer&gt; addOpIndexList = new ArrayList&lt;&gt;(patchOperationList.size());</span><br><span class="line">    List&lt;Integer&gt; replaceOpIndexList = new ArrayList&lt;&gt;(patchOperationList.size());</span><br><span class="line">    List&lt;T&gt; newItemList = new ArrayList&lt;&gt;(patchOperationList.size());</span><br><span class="line"></span><br><span class="line">    for (PatchOperation&lt;T&gt; patchOperation : patchOperationList) &#123;</span><br><span class="line">        switch (patchOperation.op) &#123;</span><br><span class="line">            case PatchOperation.OP_DEL: &#123;</span><br><span class="line">                delOpIndexList.add(patchOperation.index);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case PatchOperation.OP_ADD: &#123;</span><br><span class="line">                addOpIndexList.add(patchOperation.index);</span><br><span class="line">                newItemList.add(patchOperation.newItem);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case PatchOperation.OP_REPLACE: &#123;</span><br><span class="line">                replaceOpIndexList.add(patchOperation.index);</span><br><span class="line">                newItemList.add(patchOperation.newItem);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer.writeUleb128(delOpIndexList.size());</span><br><span class="line">    int lastIndex = 0;</span><br><span class="line">    for (Integer index : delOpIndexList) &#123;</span><br><span class="line">        buffer.writeSleb128(index - lastIndex);</span><br><span class="line">        lastIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer.writeUleb128(addOpIndexList.size());</span><br><span class="line">    lastIndex = 0;</span><br><span class="line">    for (Integer index : addOpIndexList) &#123;</span><br><span class="line">        buffer.writeSleb128(index - lastIndex);</span><br><span class="line">        lastIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer.writeUleb128(replaceOpIndexList.size());</span><br><span class="line">    lastIndex = 0;</span><br><span class="line">    for (Integer index : replaceOpIndexList) &#123;</span><br><span class="line">        buffer.writeSleb128(index - lastIndex);</span><br><span class="line">        lastIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里将我们的patchOperationList转化为3个OpIndexList,分别对应DEL，ADD，REPLACE，并且将所有的item存入newItemList.</p>
<p>然后依次写入del操作的个数，每个del的index;add操作的个数，每个add的index；replace操作的个数，每个replace的index。最后依次写入newItemList.</p>
<p>总结一下上面整个的算法流程就是一个生成patch的过程：生成一个newDex，包含各个区域的offset，可以将newDex定位到各区域的起点。包含newDex各个区域的item的删除的索引,新增的索引和值，替换的索引和值。</p>
<p>那么Patch的逻辑可能是这样的：</p>
<p>根据各个区域的offset，确定各个区域的起点；读取oldDex各个区域的items，然后根据patch去除oldDex中需要删除的和需要替换的item，再加上新增的item和替换的item即可组成newDex该区域的items。</p>
<p>即，newDex的区域应该为：</p>
<p>oldItems - del -replace + addItems + replaceItems.这就是第二部分的内容。</p>
<h5 id="差分包和原dex合成新的dex"><a href="#差分包和原dex合成新的dex" class="headerlink" title="差分包和原dex合成新的dex"></a>差分包和原dex合成新的dex</h5><p>上面说了补丁包的生成，接下来说补丁包修复的原理分析。也就是流程图中的20-23：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class DexPatchApplier &#123;</span><br><span class="line">	public DexPatchApplier(File oldDexIn, File patchFileIn) throws IOException &#123;</span><br><span class="line">        this(new Dex(oldDexIn), new DexPatchFile(patchFileIn));</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final class DexPatchFile &#123;</span><br><span class="line">	public DexPatchFile(InputStream is) throws IOException &#123;</span><br><span class="line">        this.buffer = new DexDataBuffer(ByteBuffer.wrap(FileUtils.readStream(is)));</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        byte[] magic = this.buffer.readByteArray(MAGIC.length);</span><br><span class="line">        if (CompareUtils.uArrCompare(magic, MAGIC) != 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;bad dex patch file magic: &quot; + Arrays.toString(magic));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.version = this.buffer.readShort();</span><br><span class="line">        if (CompareUtils.uCompare(this.version, CURRENT_VERSION) != 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;bad dex patch file version: &quot; + this.version + &quot;, expected: &quot; + CURRENT_VERSION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.patchedDexSize = this.buffer.readInt();</span><br><span class="line">        this.firstChunkOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedStringIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedTypeIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedProtoIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedFieldIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedMethodIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedClassDefSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedMapListSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedTypeListSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedAnnotationSetRefListSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedAnnotationSetSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedClassDataSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedCodeSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedStringDataSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedDebugInfoSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedAnnotationSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedEncodedArraySectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedAnnotationsDirectorySectionOffset = this.buffer.readInt();</span><br><span class="line">        this.oldDexSignature = this.buffer.readByteArray(SizeOf.SIGNATURE);</span><br><span class="line"></span><br><span class="line">        this.buffer.position(firstChunkOffset);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>构造函数中首先oldDex被封装为Dex对象，就是上面分析过的readHeader和readMap。不过patchFile是转化为一个DexPatchFile对象。首先将patch file读取为byte[]，然后调用其init方法，init方法首先判断MAGIC和Version，然后对patcheDexSize和各区域进行赋值，最后定位到数据区。</p>
<p>接下来的方法步骤较多，分为几个流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public DexPatchApplier(</span><br><span class="line">        Dex oldDexIn,</span><br><span class="line">        DexPatchFile patchFileIn</span><br><span class="line">) &#123;</span><br><span class="line">    this.oldDex = oldDexIn;</span><br><span class="line">    this.patchFile = patchFileIn;</span><br><span class="line">    //patchedDex作为最终输出的Dex对象</span><br><span class="line">    this.patchedDex = new Dex(patchFileIn.getPatchedDexSize());</span><br><span class="line">    this.oldToPatchedIndexMap = new SparseIndexMap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void executeAndSaveTo(File file) throws IOException &#123;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        os = new BufferedOutputStream(new FileOutputStream(file));</span><br><span class="line">            executeAndSaveTo(os);</span><br><span class="line">&#125;</span><br><span class="line">public void executeAndSaveTo(OutputStream out) throws IOException &#123;</span><br><span class="line">	// Firstly, set sections&apos; offset after patched, sort according to their offset so that</span><br><span class="line">        // the dex lib of aosp can calculate section size.</span><br><span class="line">        TableOfContents patchedToc = this.patchedDex.getTableOfContents();</span><br><span class="line"></span><br><span class="line">        patchedToc.header.off = 0;</span><br><span class="line">        patchedToc.header.size = 1;</span><br><span class="line">        patchedToc.mapList.size = 1;</span><br><span class="line"></span><br><span class="line">        patchedToc.stringIds.off</span><br><span class="line">                = this.patchFile.getPatchedStringIdSectionOffset();</span><br><span class="line">        patchedToc.typeIds.off</span><br><span class="line">                = this.patchFile.getPatchedTypeIdSectionOffset();</span><br><span class="line">        patchedToc.typeLists.off</span><br><span class="line">                = this.patchFile.getPatchedTypeListSectionOffset();</span><br><span class="line">        patchedToc.protoIds.off</span><br><span class="line">                = this.patchFile.getPatchedProtoIdSectionOffset();</span><br><span class="line">        patchedToc.fieldIds.off</span><br><span class="line">                = this.patchFile.getPatchedFieldIdSectionOffset();</span><br><span class="line">        patchedToc.methodIds.off</span><br><span class="line">                = this.patchFile.getPatchedMethodIdSectionOffset();</span><br><span class="line">        patchedToc.classDefs.off</span><br><span class="line">                = this.patchFile.getPatchedClassDefSectionOffset();</span><br><span class="line">        patchedToc.mapList.off</span><br><span class="line">                = this.patchFile.getPatchedMapListSectionOffset();</span><br><span class="line">        patchedToc.stringDatas.off</span><br><span class="line">                = this.patchFile.getPatchedStringDataSectionOffset();</span><br><span class="line">        patchedToc.annotations.off</span><br><span class="line">                = this.patchFile.getPatchedAnnotationSectionOffset();</span><br><span class="line">        patchedToc.annotationSets.off</span><br><span class="line">                = this.patchFile.getPatchedAnnotationSetSectionOffset();</span><br><span class="line">        patchedToc.annotationSetRefLists.off</span><br><span class="line">                = this.patchFile.getPatchedAnnotationSetRefListSectionOffset();</span><br><span class="line">        patchedToc.annotationsDirectories.off</span><br><span class="line">                = this.patchFile.getPatchedAnnotationsDirectorySectionOffset();</span><br><span class="line">        patchedToc.encodedArrays.off</span><br><span class="line">                = this.patchFile.getPatchedEncodedArraySectionOffset();</span><br><span class="line">        patchedToc.debugInfos.off</span><br><span class="line">                = this.patchFile.getPatchedDebugInfoSectionOffset();</span><br><span class="line">        patchedToc.codes.off</span><br><span class="line">                = this.patchFile.getPatchedCodeSectionOffset();</span><br><span class="line">        patchedToc.classDatas.off</span><br><span class="line">                = this.patchFile.getPatchedClassDataSectionOffset();</span><br><span class="line">        patchedToc.fileSize</span><br><span class="line">                = this.patchFile.getPatchedDexSize();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(patchedToc.sections);</span><br><span class="line">        patchedToc.computeSizesFromOffsets();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>1.这里读取patchFile中记录的值给patchedDex的TableOfContent中各种Section赋值，然后根据它们的偏移进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public void executeAndSaveTo(OutputStream out) throws IOException &#123;</span><br><span class="line">	// Secondly, run patch algorithms according to sections&apos; dependencies.</span><br><span class="line">        this.stringDataSectionPatchAlg = new StringDataSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.typeIdSectionPatchAlg = new TypeIdSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.protoIdSectionPatchAlg = new ProtoIdSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.fieldIdSectionPatchAlg = new FieldIdSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.methodIdSectionPatchAlg = new MethodIdSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.classDefSectionPatchAlg = new ClassDefSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.typeListSectionPatchAlg = new TypeListSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.annotationSetRefListSectionPatchAlg = new AnnotationSetRefListSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.annotationSetSectionPatchAlg = new AnnotationSetSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.classDataSectionPatchAlg = new ClassDataSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.codeSectionPatchAlg = new CodeSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.debugInfoSectionPatchAlg = new DebugInfoItemSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.annotationSectionPatchAlg = new AnnotationSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.encodedArraySectionPatchAlg = new StaticValueSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.annotationsDirectorySectionPatchAlg = new AnnotationsDirectorySectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        this.stringDataSectionPatchAlg.execute();</span><br><span class="line">        this.typeIdSectionPatchAlg.execute();</span><br><span class="line">        this.typeListSectionPatchAlg.execute();</span><br><span class="line">        this.protoIdSectionPatchAlg.execute();</span><br><span class="line">        this.fieldIdSectionPatchAlg.execute();</span><br><span class="line">        this.methodIdSectionPatchAlg.execute();</span><br><span class="line">        this.annotationSectionPatchAlg.execute();</span><br><span class="line">        this.annotationSetSectionPatchAlg.execute();</span><br><span class="line">        this.annotationSetRefListSectionPatchAlg.execute();</span><br><span class="line">        this.annotationsDirectorySectionPatchAlg.execute();</span><br><span class="line">        this.debugInfoSectionPatchAlg.execute();</span><br><span class="line">        this.codeSectionPatchAlg.execute();</span><br><span class="line">        this.classDataSectionPatchAlg.execute();</span><br><span class="line">        this.encodedArraySectionPatchAlg.execute();</span><br><span class="line">        this.classDefSectionPatchAlg.execute();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>2.这里初始化了很多算法，依次调用execute()方法。这里依旧来看stringDataSectionPatchAlg的execute方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void execute() &#123;</span><br><span class="line">    final int deletedItemCount = patchFile.getBuffer().readUleb128();</span><br><span class="line">    final int[] deletedIndices = readDeltaIndiciesOrOffsets(deletedItemCount);</span><br><span class="line"></span><br><span class="line">    final int addedItemCount = patchFile.getBuffer().readUleb128();</span><br><span class="line">    final int[] addedIndices = readDeltaIndiciesOrOffsets(addedItemCount);</span><br><span class="line"></span><br><span class="line">    final int replacedItemCount = patchFile.getBuffer().readUleb128();</span><br><span class="line">    final int[] replacedIndices = readDeltaIndiciesOrOffsets(replacedItemCount);</span><br><span class="line"></span><br><span class="line">    final TableOfContents.Section tocSec = getTocSection(this.oldDex);</span><br><span class="line">    Dex.Section oldSection = null;</span><br><span class="line"></span><br><span class="line">    int oldItemCount = 0;</span><br><span class="line">    if (tocSec.exists()) &#123;</span><br><span class="line">        oldSection = this.oldDex.openSection(tocSec);</span><br><span class="line">        oldItemCount = tocSec.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Now rest data are added and replaced items arranged in the order of</span><br><span class="line">    // added indices and replaced indices.</span><br><span class="line">    doFullPatch(</span><br><span class="line">            oldSection, oldItemCount, deletedIndices, addedIndices, replacedIndices</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里1.读取del的数量，将index存储在int数组中。2.读取add的数量，将index存储在int数组中。3.读取replace的数量，将index存储在int数组中。</p>
<p>然后就拿着deletedIndices,addedIndices,replacedIndices,oldSection, oldItemCount就能进行完整的patch了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private void doFullPatch(</span><br><span class="line">        Dex.Section oldSection,</span><br><span class="line">        int oldItemCount,</span><br><span class="line">        int[] deletedIndices,</span><br><span class="line">        int[] addedIndices,</span><br><span class="line">        int[] replacedIndices</span><br><span class="line">) &#123;</span><br><span class="line">    int deletedItemCount = deletedIndices.length;</span><br><span class="line">    int addedItemCount = addedIndices.length;</span><br><span class="line">    int replacedItemCount = replacedIndices.length;</span><br><span class="line">    int newItemCount = oldItemCount + addedItemCount - deletedItemCount;</span><br><span class="line"></span><br><span class="line">    int deletedItemCounter = 0;</span><br><span class="line">    int addActionCursor = 0;</span><br><span class="line">    int replaceActionCursor = 0;</span><br><span class="line"></span><br><span class="line">    int oldIndex = 0;</span><br><span class="line">    int patchedIndex = 0;</span><br><span class="line">    while (oldIndex &lt; oldItemCount || patchedIndex &lt; newItemCount) &#123;</span><br><span class="line">        if (addActionCursor &lt; addedItemCount &amp;&amp; addedIndices[addActionCursor] == patchedIndex) &#123;</span><br><span class="line">            T addedItem = nextItem(patchFile.getBuffer());</span><br><span class="line">            int patchedOffset = writePatchedItem(addedItem);</span><br><span class="line">            ++addActionCursor;</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (replaceActionCursor &lt; replacedItemCount &amp;&amp; replacedIndices[replaceActionCursor] == patchedIndex) &#123;</span><br><span class="line">            T replacedItem = nextItem(patchFile.getBuffer());</span><br><span class="line">            int patchedOffset = writePatchedItem(replacedItem);</span><br><span class="line">            ++replaceActionCursor;</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (Arrays.binarySearch(deletedIndices, oldIndex) &gt;= 0) &#123;</span><br><span class="line">            T skippedOldItem = nextItem(oldSection); // skip old item.</span><br><span class="line">            markDeletedIndexOrOffset(</span><br><span class="line">                    oldToPatchedIndexMap,</span><br><span class="line">                    oldIndex,</span><br><span class="line">                    getItemOffsetOrIndex(oldIndex, skippedOldItem)</span><br><span class="line">            );</span><br><span class="line">            ++oldIndex;</span><br><span class="line">            ++deletedItemCounter;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (Arrays.binarySearch(replacedIndices, oldIndex) &gt;= 0) &#123;</span><br><span class="line">            T skippedOldItem = nextItem(oldSection); // skip old item.</span><br><span class="line">            markDeletedIndexOrOffset(</span><br><span class="line">                    oldToPatchedIndexMap,</span><br><span class="line">                    oldIndex,</span><br><span class="line">                    getItemOffsetOrIndex(oldIndex, skippedOldItem)</span><br><span class="line">            );</span><br><span class="line">            ++oldIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (oldIndex &lt; oldItemCount) &#123;</span><br><span class="line">            T oldItem = adjustItem(this.oldToPatchedIndexMap, nextItem(oldSection));</span><br><span class="line"></span><br><span class="line">            int patchedOffset = writePatchedItem(oldItem);</span><br><span class="line"></span><br><span class="line">            updateIndexOrOffset(</span><br><span class="line">                    this.oldToPatchedIndexMap,</span><br><span class="line">                    oldIndex,</span><br><span class="line">                    getItemOffsetOrIndex(oldIndex, oldItem),</span><br><span class="line">                    patchedIndex,</span><br><span class="line">                    patchedOffset</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            ++oldIndex;</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是往patchedDex的stringData区写数据，写入的数据就包含：1.新增的数据。2.替代的数据。3.oldDex中除去新增和被替代的数据。</p>
<p>所以计算得到的int newItemCount = oldItemCount + addedItemCount - deletedItemCount;然后开始遍历，写入对应的item。对应的Item写入代码就包含：1.判断该patchIndex是否包含在addedIndices中，如果包含则写入；2.判断是否在replacedIndices中，如果包含则写入；3.如果在oldIndex被delete或者replace，直接跳过；4.如果是oldIndex非delete和replace的，也就是和newDex中items相同的部分。</p>
<p>1.2.4三个部分即可组成完整的newDex的该区域。这样就完成了stringData区域的patch算法，其他的14个算法的execute代码是相同的，都会完成各个部分的patch算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void executeAndSaveTo(OutputStream out) throws IOException &#123;</span><br><span class="line">// Thirdly, write header, mapList. Calculate and write patched dex&apos;s sign and checksum.</span><br><span class="line">        Dex.Section headerOut = this.patchedDex.openSection(patchedToc.header.off);</span><br><span class="line">        patchedToc.writeHeader(headerOut);</span><br><span class="line"></span><br><span class="line">        Dex.Section mapListOut = this.patchedDex.openSection(patchedToc.mapList.off);</span><br><span class="line">        patchedToc.writeMap(mapListOut);</span><br><span class="line"></span><br><span class="line">        this.patchedDex.writeHashes();</span><br><span class="line"></span><br><span class="line">        // Finally, write patched dex to file.</span><br><span class="line">        this.patchedDex.writeTo(out);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后一个步骤就是写header，mapList的数据。这样就完成了完整的dex的恢复，最后将内存中的所有数据写到文件中。</p>
<h5 id="补丁合成的原理"><a href="#补丁合成的原理" class="headerlink" title="补丁合成的原理"></a>补丁合成的原理</h5><p>前面我们已经生成了补丁包，接着通过服务器下发或者本地放入sd卡中，通过应用启动之后进行加载合成。这一节中就来讲这个具体的过程。</p>
<p>程序启动时会加载默认的Application类，将导致无法对它进行补丁修复。Tinker中为了避免这个问题，是通过将原来的Application类隔离起来，将Application类以及它的继承类的所有代码移至自己的ApplicationLike继承类中。并且把attachBaseContext方法实现单独移动到onBaseContextAttached中，这里的onBaseContextAttached并不是Application的生命周期，这个方法是在自己生成的TinkerApplication中的attachBaseContext方法中调用的，这里这样处理的目的就是为了将Application类隔离起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">@DefaultLifeCycle(application = &quot;tinker.sample.android.app.SampleApplication&quot;,</span><br><span class="line">                  flags = ShareConstants.TINKER_ENABLE_ALL,</span><br><span class="line">                  loadVerifyFlag = false)</span><br><span class="line">public class SampleApplicationLike extends DefaultApplicationLike &#123;</span><br><span class="line">    private static final String TAG = &quot;Tinker.SampleApplicationLike&quot;;</span><br><span class="line"></span><br><span class="line">    public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</span><br><span class="line">                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</span><br><span class="line">        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里通过注解生成我们真正的application类:SampleApplication.而DefaultApplicationLike是我们的代理类。这里看TinkerApplication类的实现可以看出这里用的是代理模式。</p>
<p>这里重点看TinkerApplication中的方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void onBaseContextAttached(Context base) &#123;</span><br><span class="line">    loadTinker();</span><br><span class="line">    applicationLike.onBaseContextAttached(base);</span><br><span class="line">&#125;</span><br><span class="line">private void loadTinker() &#123;</span><br><span class="line">        //reflect tinker loader, because loaderClass may be define by user!</span><br><span class="line">            Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());</span><br><span class="line"></span><br><span class="line">            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);</span><br><span class="line">            Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</span><br><span class="line">            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里通过传入的loader类，通过反射调用tryLoad方法，这里的loader类默认是TinkerLoader，这里内部会调用到tryLoadPatchFilesInternal，会判断是否开启dex修复，lib修复，资源修复，然后再分别调用TinkerDexLoader,TinkerResourceLoader等方法进行对应的修复，这里我们看dex修复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SampleApplication extends TinkerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public SampleApplication() &#123;</span><br><span class="line">        super(7, &quot;tinker.sample.android.app.SampleApplicationLike&quot;, &quot;com.tencent.tinker.loader.TinkerLoader&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TinkerLoader extends AbstractTinkerLoader &#123;</span><br><span class="line">	@Override</span><br><span class="line">    public Intent tryLoad(TinkerApplication app) &#123;</span><br><span class="line">        tryLoadPatchFilesInternal(app, resultIntent);</span><br><span class="line">        return resultIntent;</span><br><span class="line">    &#125;</span><br><span class="line">    private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultIntent) &#123;</span><br><span class="line">    ...</span><br><span class="line">    	boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);</span><br><span class="line">    	boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);</span><br><span class="line">    ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>第一步，先调用checkComplete方法从assets/dex_meta.txt中检查记录的dex信息，检查对应的dex文件是否存在，并保存到loadDexList中。</p>
<p>第二部调用TinkerDexLoader.loadTinkerJars方法会首先根据是否支持dalvik或者art做对应的处理，最后调用installDexes方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SystemClassLoaderAdder &#123;</span><br><span class="line">	@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">    public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List&lt;File&gt; files)</span><br><span class="line">        throws Throwable &#123;</span><br><span class="line">        Log.i(TAG, &quot;installDexes dexOptDir: &quot; + dexOptDir.getAbsolutePath() + &quot;, dex size:&quot; + files.size());</span><br><span class="line"></span><br><span class="line">        if (!files.isEmpty()) &#123;</span><br><span class="line">            files = createSortedAdditionalPathEntries(files);</span><br><span class="line">            ClassLoader classLoader = loader;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;= 24 &amp;&amp; !checkIsProtectedApp(files)) &#123;</span><br><span class="line">                classLoader = AndroidNClassLoader.inject(loader, application);</span><br><span class="line">            &#125;</span><br><span class="line">            //because in dalvik, if inner class is not the same classloader with it wrapper class.</span><br><span class="line">            //it won&apos;t fail at dex2opt</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">                V23.install(classLoader, files, dexOptDir);</span><br><span class="line">            &#125; else if (Build.VERSION.SDK_INT &gt;= 19) &#123;</span><br><span class="line">                V19.install(classLoader, files, dexOptDir);</span><br><span class="line">            &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</span><br><span class="line">                V14.install(classLoader, files, dexOptDir);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                V4.install(classLoader, files, dexOptDir);</span><br><span class="line">            &#125;</span><br><span class="line">            //install done</span><br><span class="line">            sPatchDexCount = files.size();</span><br><span class="line">            Log.i(TAG, &quot;after loaded classloader: &quot; + classLoader + &quot;, dex size:&quot; + sPatchDexCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里根据不同的系统版本，反射处理dexElements。看一下最新版本的SDK实现，就是V23.install方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static final class V23 &#123;</span><br><span class="line">	private static void install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">                                    File optimizedDirectory)</span><br><span class="line">            throws IllegalArgumentException, IllegalAccessException,</span><br><span class="line">            NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException &#123;</span><br><span class="line">            /* The patched class loader is expected to be a descendant of</span><br><span class="line">             * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">             * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">             * file entries.</span><br><span class="line">             */</span><br><span class="line">            Field pathListField = ShareReflectUtil.findField(loader, &quot;pathList&quot;);</span><br><span class="line">            Object dexPathList = pathListField.get(loader);</span><br><span class="line">            ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">            ShareReflectUtil.expandFieldArray(dexPathList, &quot;dexElements&quot;, makePathElements(dexPathList,</span><br><span class="line">                new ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                suppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>1.拿到PathClassLoader对象中的pathList字段</p>
<p>2.根据pathList对象找到makePathElements方法，返回Element[]数组</p>
<p>3.拿到pathList对象中原本的dexElements对象</p>
<p>4.将步骤2和步骤3中的Element[]数组合并，将patch相关的dex放在数组前面</p>
<p>5.最后将合并后的数组，设置给pathList。</p>
<p><strong>合成补丁</strong></p>
<p>在sample中是在点击Button的时候调用TinkerInstaller.onReceiveUpgradePatch(Context context, String patchLocation)方法来加载补丁，其流程如下：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\tinker打补丁包基础流程.png" alt="tinker打补丁包基础流程"></p>
<p>1-5：加载补丁文件</p>
<p>6-9：启动一个JobSeheduler来处理任务</p>
<p>10-13：启动一个AsyncTask在执行补丁包合成的任务</p>
<p>14-18：补丁包合成的核心流程，补丁包的验证，dex修复，lib修复，res修复等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,</span><br><span class="line">                                            String patchVersionDirectory, File patchFile) &#123;</span><br><span class="line">    String dexMeta = checker.getMetaContentMap().get(DEX_META_FILE)；</span><br><span class="line">    </span><br><span class="line">    boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, final File patchFile) &#123;</span><br><span class="line">        String dir = patchVersionDirectory + &quot;/&quot; + DEX_PATH + &quot;/&quot;;</span><br><span class="line"></span><br><span class="line">        if (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) &#123;</span><br><span class="line">            TinkerLog.w(TAG, &quot;patch recover, extractDiffInternals fail&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File dexFiles = new File(dir);</span><br><span class="line">        File[] files = dexFiles.listFiles();</span><br><span class="line">        List&lt;File&gt; legalFiles = new ArrayList&lt;&gt;();</span><br><span class="line">        // may have directory in android o</span><br><span class="line">        if (files != null) &#123;</span><br><span class="line">            for (File file : files) &#123;</span><br><span class="line">                if (file.isFile()) &#123;</span><br><span class="line">                    legalFiles.add(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String optimizeDexDirectory = patchVersionDirectory + &quot;/&quot; + DEX_OPTIMIZE_PATH + &quot;/&quot;;</span><br><span class="line">        return dexOptimizeDexFiles(context, legalFiles, optimizeDexDirectory, patchFile);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type) &#123;</span><br><span class="line">        //parse</span><br><span class="line">        patchList.clear();</span><br><span class="line">        ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, patchList);</span><br><span class="line"></span><br><span class="line">        File directory = new File(dir);</span><br><span class="line">        if (!directory.exists()) &#123;</span><br><span class="line">            directory.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        //I think it is better to extract the raw files from apk</span><br><span class="line">        Tinker manager = Tinker.with(context);</span><br><span class="line">        ZipFile apk = null;</span><br><span class="line">        ZipFile patch = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ApplicationInfo applicationInfo = context.getApplicationInfo();</span><br><span class="line"></span><br><span class="line">            String apkPath = applicationInfo.sourceDir;</span><br><span class="line">            apk = new ZipFile(apkPath);</span><br><span class="line">            patch = new ZipFile(patchFile);</span><br><span class="line">            </span><br><span class="line">            for (ShareDexDiffPatchInfo info : patchList) &#123;</span><br><span class="line">                long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                final String infoPath = info.path;</span><br><span class="line">                String patchRealPath;</span><br><span class="line">                if (infoPath.equals(&quot;&quot;)) &#123;</span><br><span class="line">                    patchRealPath = info.rawName;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    patchRealPath = info.path + &quot;/&quot; + info.rawName;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String dexDiffMd5 = info.dexDiffMd5;</span><br><span class="line">                String oldDexCrc = info.oldDexCrC;</span><br><span class="line"></span><br><span class="line">                if (!isVmArt &amp;&amp; info.destMd5InDvm.equals(&quot;0&quot;)) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, &quot;patch dex %s is only for art, just continue&quot;, patchRealPath);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                String extractedFileMd5 = isVmArt ? info.destMd5InArt : info.destMd5InDvm;</span><br><span class="line"></span><br><span class="line">                File extractedFile = new File(dir + info.realName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                ZipEntry patchFileEntry = patch.getEntry(patchRealPath);</span><br><span class="line">                ZipEntry rawApkFileEntry = apk.getEntry(patchRealPath);</span><br><span class="line"></span><br><span class="line">                if (oldDexCrc.equals(&quot;0&quot;)) &#123;</span><br><span class="line">                    if (patchFileEntry == null) &#123;</span><br><span class="line">                        TinkerLog.w(TAG, &quot;patch entry is null. path:&quot; + patchRealPath);</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //it is a new file, but maybe we need to repack the dex file</span><br><span class="line">                    if (!extractDexFile(patch, patchFileEntry, extractedFile, info)) &#123;</span><br><span class="line">                        TinkerLog.w(TAG, &quot;Failed to extract raw patch file &quot; + extractedFile.getPath());</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (dexDiffMd5.equals(&quot;0&quot;)) &#123;</span><br><span class="line">                    //check source crc instead of md5 for faster</span><br><span class="line">                    String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());</span><br><span class="line">                    if (!rawEntryCrc.equals(oldDexCrc)) &#123;</span><br><span class="line">                        TinkerLog.e(TAG, &quot;apk entry %s crc is not equal, expect crc: %s, got crc: %s&quot;, patchRealPath, oldDexCrc, rawEntryCrc);</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Small patched dex generating strategy was disabled, we copy full original dex directly now.</span><br><span class="line">                    //patchDexFile(apk, patch, rawApkFileEntry, null, info, smallPatchInfoFile, extractedFile);</span><br><span class="line">                    extractDexFile(apk, rawApkFileEntry, extractedFile, info);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //check source crc instead of md5 for faster</span><br><span class="line">                    String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());</span><br><span class="line">                    if (!rawEntryCrc.equals(oldDexCrc)) &#123;</span><br><span class="line">                        TinkerLog.e(TAG, &quot;apk entry %s crc is not equal, expect crc: %s, got crc: %s&quot;, patchRealPath, oldDexCrc, rawEntryCrc);</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    patchDexFile(apk, patch, rawApkFileEntry, patchFileEntry, info, extractedFile);</span><br><span class="line"></span><br><span class="line">                    if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) &#123;</span><br><span class="line">                        TinkerLog.w(TAG, &quot;Failed to recover dex file when verify patched dex: &quot; + extractedFile.getPath());</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        SharePatchFileUtil.safeDeleteFile(extractedFile);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    TinkerLog.w(TAG, &quot;success recover dex file: %s, size: %d, use time: %d&quot;,</span><br><span class="line">                        extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mergeClassNDexFiles(context, patchFile, dir)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new TinkerRuntimeException(&quot;patch &quot; + ShareTinkerInternals.getTypeString(type) + &quot; extract failed (&quot; + e.getMessage() + &quot;).&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            SharePatchFileUtil.closeZip(apk);</span><br><span class="line">            SharePatchFileUtil.closeZip(patch);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先解析meta中的信息，meta中包含了patch中每个dex的相关数据。然后拿到apk和patch的文件路径，根据文件信息进行crc校验和md5校验，然后调用patchDexFile对两个dex文件合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void patchDexFile(</span><br><span class="line">    ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,</span><br><span class="line">    ShareDexDiffPatchInfo patchInfo, File patchedDexFile) throws IOException &#123;</span><br><span class="line">    InputStream oldDexStream = null;</span><br><span class="line">    InputStream patchFileStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        oldDexStream = new BufferedInputStream(baseApk.getInputStream(oldDexEntry));</span><br><span class="line">        patchFileStream = (patchFileEntry != null ? new BufferedInputStream(patchPkg.getInputStream(patchFileEntry)) : null);</span><br><span class="line">        </span><br><span class="line">        zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(patchedDexFile)));</span><br><span class="line">                    zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));</span><br><span class="line">                    new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(zos);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>通过ZipFile拿到文件流，读取本地apk中的dex文件和patch中的dex文件，然后通过executeAndSaveTo合并到最终的patchedDexFile，也就是上面所说的生成差分包的原理。</p>
<h5 id="具体案例分析"><a href="#具体案例分析" class="headerlink" title="具体案例分析"></a>具体案例分析</h5><p>我分别编写了2个java文件，Hello.java和World.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;hello dex!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class World&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;nani World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hello.dex和World.dex结构分别如下：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\Hello.dex结构.jpg" alt="Hello.dex结构"></p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\World.dex结构.jpg" alt="World.dex结构"></p>
<p>按照之前的diff算法，得到以下操作：</p>
<p>del 1 </p>
<p>del 2 </p>
<p>add 1 LWorld;</p>
<p>add 8 World.java</p>
<p>del 10 </p>
<p>add 11 nani World</p>
<p>然后根据索引排序：</p>
<p>del 1 </p>
<p>add 1 LWorld;</p>
<p>del 2 </p>
<p>add 8 World.java</p>
<p>del 10 </p>
<p>add 11 nani World</p>
<p>将index一致且DEL和ADD相邻的操作替换为replace:</p>
<p>replace 1 LWorld</p>
<p>del 2</p>
<p>add 8 World.java</p>
<p>del 10 </p>
<p>add 11 nani World</p>
<p>在write时，按照DEL,ADD,REPLACE进行分类，并将出现的item放置到newItemList：</p>
<p>del ops:</p>
<p>​    del 2</p>
<p>​    del 10</p>
<p>add ops:</p>
<p>​    add 8</p>
<p>​    add 11</p>
<p>replace ops:</p>
<p>​    1</p>
<p>newItemList为：</p>
<p>LWorld //replace 1</p>
<p>World.java //add8</p>
<p>naniWorld //add11</p>
<p>然后写入，写入的顺序为：</p>
<p>2 //del size</p>
<p>2</p>
<p>8 //index - lastIndex</p>
<p>2 //add size</p>
<p>8</p>
<p>3 // index - lastIndex</p>
<p>1 //replace size</p>
<p>1</p>
<p>LWorld</p>
<p>World.java</p>
<p>naniWorld</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/lmj623565791/article/details/60874334#t6" target="_blank" rel="noopener">Android 热修复 Tinker 源码分析之DexDiff / DexPatch</a></p>
<p><a href="https://www.zybuluo.com/dodola/note/554061" target="_blank" rel="noopener">Tinker</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/28/热修复方案对比/" rel="next" title="[object Object]">
                <i class="fa fa-chevron-left"></i> [object Object]
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">youpeng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/youuupeng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tinker原理解析"><span class="nav-number">1.</span> <span class="nav-text">Tinker原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#补丁包生成原理"><span class="nav-number">1.1.</span> <span class="nav-text">补丁包生成原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#知识准备"><span class="nav-number">1.2.</span> <span class="nav-text">知识准备</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#生成dex"><span class="nav-number">1.2.1.</span> <span class="nav-text">生成dex</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一种可能的tinkerPatch算法"><span class="nav-number">1.3.</span> <span class="nav-text">一种可能的tinkerPatch算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#生成差分包的原理"><span class="nav-number">1.4.</span> <span class="nav-text">生成差分包的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#差分包和原dex合成新的dex"><span class="nav-number">1.5.</span> <span class="nav-text">差分包和原dex合成新的dex</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#补丁合成的原理"><span class="nav-number">1.6.</span> <span class="nav-text">补丁合成的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#具体案例分析"><span class="nav-number">1.7.</span> <span class="nav-text">具体案例分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考"><span class="nav-number">2.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youpeng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
