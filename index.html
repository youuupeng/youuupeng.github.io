<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://youuupeng.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://youuupeng.github.io/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/android/hotfix/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://youuupeng.github.io/2019/02/20/Tinker原理解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youpeng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/20/Tinker原理解析/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T16:15:56+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>title:Tinker原理解析</p>
<hr>
<p>[TOC]</p>
<h4 id="Tinker原理解析"><a href="#Tinker原理解析" class="headerlink" title="Tinker原理解析"></a>Tinker原理解析</h4><h5 id="补丁包生成原理"><a href="#补丁包生成原理" class="headerlink" title="补丁包生成原理"></a>补丁包生成原理</h5><p>Tinker打补丁主要为两个步骤：1.通过执行gradke task tinkerPatchDebug(Release)生成补丁包。2.通过tinkerInstaller将补丁包进行合成。</p>
<p>我们先来分析第一步：tinkerPatchDebug task包括两个步骤，1.执行debug生成修复代码之后的apk。2.执行tinkerPatch生成补丁包。</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\tinkerPatch相关流程.png" alt="tinkerPatch相关流程"></p>
<p>1-7：构建gradle tinkerPatch task</p>
<p>8-9：将新旧apk对比构建补丁包：将两个apk的内容读取到流中，对比是否有新添加的class文件</p>
<p>10-15：将apk以流的形式读取，进行对比</p>
<p>16-19：patch补丁包生成</p>
<p>20-23：将patch补丁和原来的apk合成新的修复过后的apk</p>
<p>可以看出，这里的核心在于16-23，就是<strong>如何生成补丁包</strong>和<strong>进行补丁包的修复</strong>。下面我会主要从这两两个角度进行原理剖析。</p>
<p>在具体讲tinker是如何实现这部分模块之前先介绍一下准备知识。</p>
<h5 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h5><h6 id="生成dex"><a href="#生成dex" class="headerlink" title="生成dex"></a>生成dex</h6><p>编写一个Hello.java文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;hello dex!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成Hello.class文件：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\生成class文件.jpg" alt="生成class文件"></p>
<p>然后把java文件和class文件放到sdk-&gt;build-tools-&gt;23.0.1中，生成dex文件：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\生成dex出错.jpg" alt="生成dex出错"></p>
<p>会发现放在23.0.1下边出错，我把它放到28.0.2下边就正常了，可能低版本有点问题。最后会有3个文件：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\java class dex文件.jpg" alt="java class dex文件"></p>
<p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="noopener">dex的内部结构</a>如下</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex文件结构(1" alt="dex文件结构(1)">.jpg)</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex文件结构(2" alt="dex文件结构(2)">.jpg)</p>
<p>下边这张图更直观一点：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex文件结构.jpg" alt="dex文件结构"></p>
<p>dex是使用LEB128编码的，用<a href="http://www.sweetscape.com/010editor/" target="_blank" rel="noopener">010Editor</a>可以看dex文件。可以看到010Editor解析出来的数据基本跟dex文件结构对应，link_data在010Editor中表示为map_list</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex大致结构.jpg" alt="dex大致结构"></p>
<p>这里我们主要对dex_header和map_list做大致的分析：</p>
<p><strong>dex_header</strong>：</p>
<p>magic：魔法值DEX_FILE_MAGIC。用来标识是dex文件，java的魔法值是CAFFEEBABE。</p>
<p>其他相关字段含义：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex_header字段含义.jpg" alt="dex_header字段含义"></p>
<p>注意，从下面的图中可以看到，dex_header中的string_ids_size,string_ids_off这种成对出现的分别代表大小和偏移量，对应着下面出现的其他表的数据。</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex具体结构.jpg" alt="dex具体结构"></p>
<p><strong>dex_map_list</strong></p>
<p>其对应的结构如下：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\dex_map_list结构.jpg" alt="dex_map_list结构"></p>
<p>每个map_item_list包含一个enum表示类型,一个ushort未使用的成员,一个uint表示当前类型的个数，一个uint表示当前类型偏移量。</p>
<p>首先是TYPE_HEADER_ITEM类型，包含1个header（size=1），偏移量为0</p>
<p>然后是TYPE_STRING_ID_ITEM,包含14个string_id_item(size=14),偏移量为112.跟前面dex_header中的数据是一样的。</p>
<p>以此类推。通过map_list，可以将一个完整的dex文件划分成固定的区域，且知道每个区域的开始，以及该区域对应的数据格式的个数。</p>
<h5 id="一种可能的tinkerPatch算法"><a href="#一种可能的tinkerPatch算法" class="headerlink" title="一种可能的tinkerPatch算法"></a>一种可能的tinkerPatch算法</h5><p>在tinker中，我们是生成了新旧apk，其内部是通过对比差异来得出一个差量包，其对比的文件就是dex为单位。</p>
<p>在对比前，有两个dex:1.old dex.2.new dex。对比生成一个patch文件，然后patch文件可以和old dex通过算法合成一个新的dex。</p>
<p>那么patch + old dex-&gt;new dex的步骤就包括几个部分：</p>
<p>1.header不作处理，因为可以根据其他数据生成；</p>
<p>2.map list。获取各个区域的offset偏移值</p>
<p>3.知道了各个区域的offset后，在生成new dex的时候，定位各个区域的开始和结束为止，往各个区域写数据即可。</p>
<p>假设针对一个区域的diff，假设有个string 区域，用于存储字符串：</p>
<p>old dex区域的字符串:Hello World</p>
<p>new dex区域的字符串：Hello dex</p>
<p>可以看出该区域，我们删除了World，增加了dex，那么patch中针对该区域可以作如下记录：“del World,add dex”（实际转换成对应的编码）那么在patch的时候可以很容易的计算出new dex最后的结果为：Hello dex。这样就是一个大致的diff和patch算法。</p>
<p>tinker就是基于上面这样的思想来实现的，当然实际情况比这个要复杂的多。</p>
<h5 id="生成差分包的原理"><a href="#生成差分包的原理" class="headerlink" title="生成差分包的原理"></a>生成差分包的原理</h5><p>从前面的流程图可以看到补丁包的生成过程是在16-19。</p>
<p>15的代码如下：</p>
<p>以下代码为了方便理解都有一定的删减。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void diffDexPairAndFillRelatedInfo(File oldDexFile, File newDexFile, RelatedInfo relatedInfo) &#123;</span><br><span class="line">    DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldDexFile, newDexFile);</span><br><span class="line">    dexPatchGen.executeAndSaveTo(dexDiffOut);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里有两个步骤。</p>
<p>1：DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldDexFile, newDexFile); </p>
<p>2：dexPatchGen.executeAndSaveTo(dexDiffOut);</p>
<p>接下来我们先看1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class DexPatchGenerator &#123;</span><br><span class="line">	public DexPatchGenerator(File oldDexFile, File newDexFile) throws IOException &#123;</span><br><span class="line">   		 this(new Dex(oldDexFile), new Dex(newDexFile));</span><br><span class="line">	&#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final class Dex &#123;</span><br><span class="line">	public Dex(File file) throws IOException &#123;</span><br><span class="line">        loadFrom(inputStream, (int) entry.getSize());</span><br><span class="line">    ｝  </span><br><span class="line">    private void loadFrom(InputStream in, int initSize) throws IOException &#123;</span><br><span class="line">        byte[] rawData = FileUtils.readStream(in, initSize);</span><br><span class="line">        this.data = ByteBuffer.wrap(rawData);</span><br><span class="line">        this.data.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">        this.tableOfContents.readFrom(this);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final class TableOfContents &#123;</span><br><span class="line">	public void readFrom(Dex dex) throws IOException &#123;</span><br><span class="line">        readHeader(dex.openSection(header));</span><br><span class="line">        readMap(dex.openSection(mapList.off));</span><br><span class="line">        computeSizesFromOffsets();</span><br><span class="line">    &#125;</span><br><span class="line">    //这里就是将dex中的字段读取出来保存起来</span><br><span class="line">    private void readHeader(Dex.Section headerIn) throws UnsupportedEncodingException &#123;</span><br><span class="line">        byte[] magic = headerIn.readByteArray(8);</span><br><span class="line">        checksum = headerIn.readInt();</span><br><span class="line">        signature = headerIn.readByteArray(20);</span><br><span class="line">        fileSize = headerIn.readInt();</span><br><span class="line">        int headerSize = headerIn.readInt();</span><br><span class="line">        int endianTag = headerIn.readInt();</span><br><span class="line">        linkSize = headerIn.readInt();</span><br><span class="line">        linkOff = headerIn.readInt();</span><br><span class="line">        mapList.off = headerIn.readInt();</span><br><span class="line">      ｝</span><br><span class="line">      private void readMap(Dex.Section in) throws IOException &#123;</span><br><span class="line">        int mapSize = in.readInt();</span><br><span class="line">        Section previous = null;</span><br><span class="line">        for (int i = 0; i &lt; mapSize; i++) &#123;</span><br><span class="line">            short type = in.readShort();</span><br><span class="line">            in.readShort(); // unused</span><br><span class="line">            Section section = getSection(type);</span><br><span class="line">            int size = in.readInt();</span><br><span class="line">            int offset = in.readInt();</span><br><span class="line">            section.size = size;</span><br><span class="line">            section.off = offset;</span><br><span class="line">            previous = section;</span><br><span class="line">        &#125;</span><br><span class="line">        header.off = 0;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里的核心就在于readHeader和readMap，在这两个步骤完成之后就完成了dex文件到dex对象的初始化。</p>
<p>在读取header的时候，已经读取了除了map list区域的offset,并存储在mapList.off中。所以readMap中传入的是这个参数，开始读取map list的数据。首先读取的是map_list_item的个数，然后在for循环中便利读取每个map_list_item的实际数据。</p>
<p>依次读取的数据为：type,unused,size,offset，这些都是跟我们前面讲的map_list_item对应的，在Tinker中对应的对象为TableContents.Section对象。</p>
<p>至此，拿到了两个Dex对象，接下来开始做diff操作。</p>
<p>步骤1我们已经分析完了，接下来看步骤2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class DexPatchGenerator &#123;</span><br><span class="line">	public DexPatchGenerator(Dex oldDex, Dex newDex) &#123;</span><br><span class="line">        this.oldDex = oldDex;</span><br><span class="line">        this.newDex = newDex;</span><br><span class="line">        //这里初始化15个算法，每个算法代表dex的每个字段，算法的作用就是我们之前说的那种算法，用来计算增加了哪些，需要删除哪些</span><br><span class="line">        this.stringDataSectionDiffAlg = new StringDataSectionDiffAlgorithm</span><br><span class="line">        this.typeIdSectionDiffAlg = new TypeIdSectionDiffAlgorithm</span><br><span class="line">        this.protoIdSectionDiffAlg = new ProtoIdSectionDiffAlgorithm</span><br><span class="line">        this.fieldIdSectionDiffAlg = new FieldIdSectionDiffAlgorithm</span><br><span class="line">        this.methodIdSectionDiffAlg = new MethodIdSectionDiffAlgorithm</span><br><span class="line">        ···（省略）</span><br><span class="line">        this.codeSectionDiffAlg = new CodeSectionDiffAlgorithm(</span><br><span class="line">                oldDex, newDex,</span><br><span class="line">                oldToNewIndexMap,</span><br><span class="line">                oldToPatchedIndexMap,</span><br><span class="line">                newToPatchedIndexMap,</span><br><span class="line">                selfIndexMapForSkip</span><br><span class="line">        );</span><br><span class="line">    ｝</span><br><span class="line">    public void executeAndSaveTo(File file) throws IOException &#123;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        os = new BufferedOutputStream(new FileOutputStream(file));</span><br><span class="line">            executeAndSaveTo(os);</span><br><span class="line">    &#125;</span><br><span class="line">    public void executeAndSaveTo(OutputStream out) throws IOException &#123;</span><br><span class="line">    //1.执行execute方法</span><br><span class="line">    	this.stringDataSectionDiffAlg.execute();</span><br><span class="line">         //2.执行simulatePatchOperation方法</span><br><span class="line">         this.stringDataSectionDiffAlg.simulatePatchOperation(this.patchedStringDataItemsOffset);</span><br><span class="line"></span><br><span class="line">        this.typeIdSectionDiffAlg.execute();</span><br><span class="line">        this.typeIdSectionDiffAlg.simulatePatchOperation(this.patchedTypeIdsOffset);</span><br><span class="line">        this.typeListSectionDiffAlg.execute();</span><br><span class="line">this.typeListSectionDiffAlg.simulatePatchOperation(this.patchedTypeListsOffset);</span><br><span class="line">	...</span><br><span class="line">		</span><br><span class="line">		// Finally, write results to patch file.</span><br><span class="line">        writeResultToStream(out);</span><br><span class="line">    ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里初始化每个算法之后主要执行3个操作，一个是execute方法，另一个是simulatePatchOperation方法，最后是执行writeResultToStream方法。这里先看execute方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public abstract class DexSectionDiffAlgorithm&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line">	public void execute() &#123;</span><br><span class="line">		this.patchOperationList.clear();</span><br><span class="line">		//1.拿到oldDex和newDex的itemList，进行调整排序</span><br><span class="line">        this.adjustedOldIndexedItemsWithOrigOrder = collectSectionItems(this.oldDex, true);</span><br><span class="line">        this.oldItemCount = this.adjustedOldIndexedItemsWithOrigOrder.length;</span><br><span class="line"></span><br><span class="line">        AbstractMap.SimpleEntry&lt;Integer, T&gt;[] adjustedOldIndexedItems = new AbstractMap.SimpleEntry[this.oldItemCount];</span><br><span class="line">        System.arraycopy(this.adjustedOldIndexedItemsWithOrigOrder, 0, adjustedOldIndexedItems, 0, this.oldItemCount);</span><br><span class="line">        Arrays.sort(adjustedOldIndexedItems, this.comparatorForItemDiff);</span><br><span class="line"></span><br><span class="line">        AbstractMap.SimpleEntry&lt;Integer, T&gt;[] adjustedNewIndexedItems = collectSectionItems(this.newDex, false);</span><br><span class="line">        this.newItemCount = adjustedNewIndexedItems.length;</span><br><span class="line">        Arrays.sort(adjustedNewIndexedItems, this.comparatorForItemDiff);</span><br><span class="line"></span><br><span class="line">        int oldCursor = 0;</span><br><span class="line">        int newCursor = 0;</span><br><span class="line">        //2.遍历，对比，收集patch操作</span><br><span class="line">        while (oldCursor &lt; this.oldItemCount || newCursor &lt; this.newItemCount) &#123;</span><br><span class="line">            if (oldCursor &gt;= this.oldItemCount) &#123;</span><br><span class="line">                // rest item are all newItem.</span><br><span class="line">                while (newCursor &lt; this.newItemCount) &#123;</span><br><span class="line">                //剩下的都是newIten，做ADD操作</span><br><span class="line">                    AbstractMap.SimpleEntry&lt;Integer, T&gt; newIndexedItem = adjustedNewIndexedItems[newCursor++];</span><br><span class="line">                    this.patchOperationList.add(new PatchOperation&lt;&gt;(PatchOperation.OP_ADD, newIndexedItem.getKey(), newIndexedItem.getValue()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else</span><br><span class="line">            if (newCursor &gt;= newItemCount) &#123;</span><br><span class="line">                // rest item are all oldItem.</span><br><span class="line">                while (oldCursor &lt; oldItemCount) &#123;</span><br><span class="line">                //剩下的都是oldItem，做DEL操作</span><br><span class="line">                    AbstractMap.SimpleEntry&lt;Integer, T&gt; oldIndexedItem = adjustedOldIndexedItems[oldCursor++];</span><br><span class="line">                    int deletedIndex = oldIndexedItem.getKey();</span><br><span class="line">                    int deletedOffset = getItemOffsetOrIndex(deletedIndex, oldIndexedItem.getValue());</span><br><span class="line">                    this.patchOperationList.add(new PatchOperation&lt;T&gt;(PatchOperation.OP_DEL, deletedIndex));</span><br><span class="line">                    markDeletedIndexOrOffset(this.oldToPatchedIndexMap, deletedIndex, deletedOffset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                AbstractMap.SimpleEntry&lt;Integer, T&gt; oldIndexedItem = adjustedOldIndexedItems[oldCursor];</span><br><span class="line">                AbstractMap.SimpleEntry&lt;Integer, T&gt; newIndexedItem = adjustedNewIndexedItems[newCursor];</span><br><span class="line">                int cmpRes = oldIndexedItem.getValue().compareTo(newIndexedItem.getValue());</span><br><span class="line">                if (cmpRes &lt; 0) &#123;</span><br><span class="line">                    int deletedIndex = oldIndexedItem.getKey();</span><br><span class="line">                    int deletedOffset = getItemOffsetOrIndex(deletedIndex, oldIndexedItem.getValue());</span><br><span class="line">                    this.patchOperationList.add(new PatchOperation&lt;T&gt;(PatchOperation.OP_DEL, deletedIndex));</span><br><span class="line">                    markDeletedIndexOrOffset(this.oldToPatchedIndexMap, deletedIndex, deletedOffset);</span><br><span class="line">                    ++oldCursor;</span><br><span class="line">                &#125; else</span><br><span class="line">                if (cmpRes &gt; 0) &#123;</span><br><span class="line">                    this.patchOperationList.add(new PatchOperation&lt;&gt;(PatchOperation.OP_ADD, newIndexedItem.getKey(), newIndexedItem.getValue()));</span><br><span class="line">                    ++newCursor;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int oldIndex = oldIndexedItem.getKey();</span><br><span class="line">                    int newIndex = newIndexedItem.getKey();</span><br><span class="line">                    int oldOffset = getItemOffsetOrIndex(oldIndexedItem.getKey(), oldIndexedItem.getValue());</span><br><span class="line">                    int newOffset = getItemOffsetOrIndex(newIndexedItem.getKey(), newIndexedItem.getValue());</span><br><span class="line"></span><br><span class="line">                    if (oldIndex != newIndex) &#123;</span><br><span class="line">                        this.oldIndexToNewIndexMap.put(oldIndex, newIndex);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (oldOffset != newOffset) &#123;</span><br><span class="line">                        this.oldOffsetToNewOffsetMap.put(oldOffset, newOffset);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ++oldCursor;</span><br><span class="line">                    ++newCursor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边首先拿到oldDex和newDex做调整，排序。然后开始遍历获取oldItem和newItem，对比其value:</p>
<p>如果&lt;0,则认为该old item被删除，记录为PatchOperation.OP_DEL,并将该oldItem index记录到PatchOperation对象，加入到patchOperationList中。</p>
<p>如果&gt;0,则认为该newItem是新增的，记录为PatchOperation.OP_ADD,并记录该newItem index和value到PatchOperation对象，加入到patchOperationList中。</p>
<p>如果=0，不会生成PatchOperation。</p>
<p>（这里看注释是&lt;0则删除，&gt;0是增加，但是是为什么啊？）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public void execute() &#123;</span><br><span class="line">	// So far all diff works are done. Then we perform some optimize works.</span><br><span class="line">        // detail: &#123;OP_DEL idx&#125; followed by &#123;OP_ADD the_same_idx newItem&#125;</span><br><span class="line">        // will be replaced by &#123;OP_REPLACE idx newItem&#125;</span><br><span class="line">        Collections.sort(this.patchOperationList, comparatorForPatchOperationOpt);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;PatchOperation&lt;T&gt;&gt; patchOperationIt = this.patchOperationList.iterator();</span><br><span class="line">        PatchOperation&lt;T&gt; prevPatchOperation = null;</span><br><span class="line">        while (patchOperationIt.hasNext()) &#123;</span><br><span class="line">            PatchOperation&lt;T&gt; patchOperation = patchOperationIt.next();</span><br><span class="line">            if (prevPatchOperation != null</span><br><span class="line">                &amp;&amp; prevPatchOperation.op == PatchOperation.OP_DEL</span><br><span class="line">                &amp;&amp; patchOperation.op == PatchOperation.OP_ADD</span><br><span class="line">            ) &#123;</span><br><span class="line">                if (prevPatchOperation.index == patchOperation.index) &#123;</span><br><span class="line">                    prevPatchOperation.op = PatchOperation.OP_REPLACE;</span><br><span class="line">                    prevPatchOperation.newItem = patchOperation.newItem;</span><br><span class="line">                    patchOperationIt.remove();</span><br><span class="line">                    prevPatchOperation = null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    prevPatchOperation = patchOperation;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prevPatchOperation = patchOperation;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finally we record some information for the final calculations.</span><br><span class="line">        patchOperationIt = this.patchOperationList.iterator();</span><br><span class="line">        while (patchOperationIt.hasNext()) &#123;</span><br><span class="line">            PatchOperation&lt;T&gt; patchOperation = patchOperationIt.next();</span><br><span class="line">            switch (patchOperation.op) &#123;</span><br><span class="line">                case PatchOperation.OP_DEL: &#123;</span><br><span class="line">                    indexToDelOperationMap.put(patchOperation.index, patchOperation);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case PatchOperation.OP_ADD: &#123;</span><br><span class="line">                    indexToAddOperationMap.put(patchOperation.index, patchOperation);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case PatchOperation.OP_REPLACE: &#123;</span><br><span class="line">                    indexToReplaceOperationMap.put(patchOperation.index, patchOperation);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面得到了一个patchOperationList对象之后，先对其进行排序。</p>
<p>然后执行一些优化操作，同一个index的item的OP_DEL操作后边紧跟着OP_ADD操作会被替换成OP_REPLACE。</p>
<p>然后最后生成3个Map:indexToDelOperationMap,indexToAddOperationMap,indexToReplaceOperationMap.</p>
<p>至此，完成了需要删除，添加，替换的item收集。</p>
<p>接着看simulatePatchOperation方法:</p>
<p>参数传入的偏移量为data区域的偏移量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public void simulatePatchOperation(int baseOffset) &#123;</span><br><span class="line">    boolean isNeedToMakeAlign = getTocSection(this.oldDex).isElementFourByteAligned;</span><br><span class="line">    int oldIndex = 0;</span><br><span class="line">    int patchedIndex = 0;</span><br><span class="line">    int patchedOffset = baseOffset;</span><br><span class="line">    while (oldIndex &lt; this.oldItemCount || patchedIndex &lt; this.newItemCount) &#123;</span><br><span class="line">        if (this.indexToAddOperationMap.containsKey(patchedIndex)) &#123;</span><br><span class="line">            PatchOperation&lt;T&gt; patchOperation = this.indexToAddOperationMap.get(patchedIndex);</span><br><span class="line">            if (isNeedToMakeAlign) &#123;</span><br><span class="line">                patchedOffset = SizeOf.roundToTimesOfFour(patchedOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            T newItem = patchOperation.newItem;</span><br><span class="line">            int itemSize = getItemSize(newItem);</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">            patchedOffset += itemSize;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (this.indexToReplaceOperationMap.containsKey(patchedIndex)) &#123;</span><br><span class="line">            PatchOperation&lt;T&gt; patchOperation = this.indexToReplaceOperationMap.get(patchedIndex);</span><br><span class="line">            T newItem = patchOperation.newItem;</span><br><span class="line">            int itemSize = getItemSize(newItem);</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">            patchedOffset += itemSize;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (this.indexToDelOperationMap.containsKey(oldIndex)) &#123;</span><br><span class="line">            ++oldIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (this.indexToReplaceOperationMap.containsKey(oldIndex)) &#123;</span><br><span class="line">            ++oldIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (oldIndex &lt; this.oldItemCount) &#123;</span><br><span class="line">            T oldItem = this.adjustedOldIndexedItemsWithOrigOrder[oldIndex].getValue();</span><br><span class="line">            int itemSize = getItemSize(oldItem);</span><br><span class="line"></span><br><span class="line">            int oldOffset = getItemOffsetOrIndex(oldIndex, oldItem);</span><br><span class="line">            int newIndex = oldIndex;</span><br><span class="line">            if (this.oldIndexToNewIndexMap.containsKey(oldIndex)) &#123;</span><br><span class="line">                newIndex = this.oldIndexToNewIndexMap.get(oldIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int newOffset = oldOffset;</span><br><span class="line">            if (this.oldOffsetToNewOffsetMap.containsKey(oldOffset)) &#123;</span><br><span class="line">                newOffset = this.oldOffsetToNewOffsetMap.get(oldOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            ++oldIndex;</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">            patchedOffset += itemSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.patchedSectionSize = SizeOf.roundToTimesOfFour(patchedOffset - baseOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里遍历oldIndex和patchIndex，分别在indexToAddOperationMap，indexToReplaceOperationMap，indexToDelOperationMap中查找。</p>
<p>最后生成patchedSectionSize，由patchedOffset - baseOffset计算得到。</p>
<p>这里在3个地方会执行patchedOffset += itemSize;</p>
<p>分别是if (this.indexToAddOperationMap.containsKey(patchedIndex))，if (this.indexToReplaceOperationMap.containsKey(patchedIndex))，if (oldIndex &lt; this.oldItemCount)从这几个判断条件可以看出，首先patchedSectionSize对应newDex的这个区域的size，所以，需要ADD的itemIndex,需要被替代的itemIndex，以及OLD ITEMS中没有被删除和替代的item，这三个加起来就是newIndex的itemList.</p>
<p>经过上面两个操作，得到PatchOperationList和对应区域的sectionSize，执行完所有的算法，就会得到针对每个算法的PatchOperationList和每个区域的sectionSize;每个区域的sectionSize再根据每个区域对应的字节单位长度计算得到每个区域的offset。</p>
<p>这里看最后一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private void writeResultToStream(OutputStream os) throws IOException &#123;</span><br><span class="line">    DexDataBuffer buffer = new DexDataBuffer();</span><br><span class="line">    buffer.write(DexPatchFile.MAGIC);</span><br><span class="line">    buffer.writeShort(DexPatchFile.CURRENT_VERSION);</span><br><span class="line">    buffer.writeInt(this.patchedDexSize);</span><br><span class="line">    // we will return here to write firstChunkOffset later.</span><br><span class="line">    int posOfFirstChunkOffsetField = buffer.position();</span><br><span class="line">    buffer.writeInt(0);</span><br><span class="line">    buffer.writeInt(this.patchedStringIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedTypeIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedProtoIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedFieldIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedMethodIdsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedClassDefsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedMapListOffset);</span><br><span class="line">    buffer.writeInt(this.patchedTypeListsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedAnnotationSetRefListItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedAnnotationSetItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedClassDataItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedCodeItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedStringDataItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedDebugInfoItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedAnnotationItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedEncodedArrayItemsOffset);</span><br><span class="line">    buffer.writeInt(this.patchedAnnotationsDirectoryItemsOffset);</span><br><span class="line">    buffer.write(this.oldDex.computeSignature(false));</span><br><span class="line">    int firstChunkOffset = buffer.position();</span><br><span class="line">    buffer.position(posOfFirstChunkOffsetField);</span><br><span class="line">    buffer.writeInt(firstChunkOffset);</span><br><span class="line">    buffer.position(firstChunkOffset);</span><br><span class="line"></span><br><span class="line">    writePatchOperations(buffer, this.stringDataSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.typeIdSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.typeListSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.protoIdSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.fieldIdSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.methodIdSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.annotationSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.annotationSetSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.annotationSetRefListSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.annotationsDirectorySectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.debugInfoSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.codeSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.classDataSectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.encodedArraySectionDiffAlg.getPatchOperationList());</span><br><span class="line">    writePatchOperations(buffer, this.classDefSectionDiffAlg.getPatchOperationList());</span><br><span class="line"></span><br><span class="line">    byte[] bufferData = buffer.array();</span><br><span class="line">    os.write(bufferData);</span><br><span class="line">    os.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要写入dex中的header的相关字段，然后写入所有的跟maplist各个区域相关的offset。然后调用各个区域对应算法写入信息，最后生成patch文件。这里以stringDataSectionDiffAlg为例，看下其源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T extends Comparable&lt;T&gt;&gt; void writePatchOperations(</span><br><span class="line">        DexDataBuffer buffer, List&lt;PatchOperation&lt;T&gt;&gt; patchOperationList</span><br><span class="line">) &#123;</span><br><span class="line">    List&lt;Integer&gt; delOpIndexList = new ArrayList&lt;&gt;(patchOperationList.size());</span><br><span class="line">    List&lt;Integer&gt; addOpIndexList = new ArrayList&lt;&gt;(patchOperationList.size());</span><br><span class="line">    List&lt;Integer&gt; replaceOpIndexList = new ArrayList&lt;&gt;(patchOperationList.size());</span><br><span class="line">    List&lt;T&gt; newItemList = new ArrayList&lt;&gt;(patchOperationList.size());</span><br><span class="line"></span><br><span class="line">    for (PatchOperation&lt;T&gt; patchOperation : patchOperationList) &#123;</span><br><span class="line">        switch (patchOperation.op) &#123;</span><br><span class="line">            case PatchOperation.OP_DEL: &#123;</span><br><span class="line">                delOpIndexList.add(patchOperation.index);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case PatchOperation.OP_ADD: &#123;</span><br><span class="line">                addOpIndexList.add(patchOperation.index);</span><br><span class="line">                newItemList.add(patchOperation.newItem);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case PatchOperation.OP_REPLACE: &#123;</span><br><span class="line">                replaceOpIndexList.add(patchOperation.index);</span><br><span class="line">                newItemList.add(patchOperation.newItem);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer.writeUleb128(delOpIndexList.size());</span><br><span class="line">    int lastIndex = 0;</span><br><span class="line">    for (Integer index : delOpIndexList) &#123;</span><br><span class="line">        buffer.writeSleb128(index - lastIndex);</span><br><span class="line">        lastIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer.writeUleb128(addOpIndexList.size());</span><br><span class="line">    lastIndex = 0;</span><br><span class="line">    for (Integer index : addOpIndexList) &#123;</span><br><span class="line">        buffer.writeSleb128(index - lastIndex);</span><br><span class="line">        lastIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer.writeUleb128(replaceOpIndexList.size());</span><br><span class="line">    lastIndex = 0;</span><br><span class="line">    for (Integer index : replaceOpIndexList) &#123;</span><br><span class="line">        buffer.writeSleb128(index - lastIndex);</span><br><span class="line">        lastIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里将我们的patchOperationList转化为3个OpIndexList,分别对应DEL，ADD，REPLACE，并且将所有的item存入newItemList.</p>
<p>然后依次写入del操作的个数，每个del的index;add操作的个数，每个add的index；replace操作的个数，每个replace的index。最后依次写入newItemList.</p>
<p>总结一下上面整个的算法流程就是一个生成patch的过程：生成一个newDex，包含各个区域的offset，可以将newDex定位到各区域的起点。包含newDex各个区域的item的删除的索引,新增的索引和值，替换的索引和值。</p>
<p>那么Patch的逻辑可能是这样的：</p>
<p>根据各个区域的offset，确定各个区域的起点；读取oldDex各个区域的items，然后根据patch去除oldDex中需要删除的和需要替换的item，再加上新增的item和替换的item即可组成newDex该区域的items。</p>
<p>即，newDex的区域应该为：</p>
<p>oldItems - del -replace + addItems + replaceItems.这就是第二部分的内容。</p>
<h5 id="差分包和原dex合成新的dex"><a href="#差分包和原dex合成新的dex" class="headerlink" title="差分包和原dex合成新的dex"></a>差分包和原dex合成新的dex</h5><p>上面说了补丁包的生成，接下来说补丁包修复的原理分析。也就是流程图中的20-23：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class DexPatchApplier &#123;</span><br><span class="line">	public DexPatchApplier(File oldDexIn, File patchFileIn) throws IOException &#123;</span><br><span class="line">        this(new Dex(oldDexIn), new DexPatchFile(patchFileIn));</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final class DexPatchFile &#123;</span><br><span class="line">	public DexPatchFile(InputStream is) throws IOException &#123;</span><br><span class="line">        this.buffer = new DexDataBuffer(ByteBuffer.wrap(FileUtils.readStream(is)));</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        byte[] magic = this.buffer.readByteArray(MAGIC.length);</span><br><span class="line">        if (CompareUtils.uArrCompare(magic, MAGIC) != 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;bad dex patch file magic: &quot; + Arrays.toString(magic));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.version = this.buffer.readShort();</span><br><span class="line">        if (CompareUtils.uCompare(this.version, CURRENT_VERSION) != 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;bad dex patch file version: &quot; + this.version + &quot;, expected: &quot; + CURRENT_VERSION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.patchedDexSize = this.buffer.readInt();</span><br><span class="line">        this.firstChunkOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedStringIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedTypeIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedProtoIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedFieldIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedMethodIdSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedClassDefSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedMapListSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedTypeListSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedAnnotationSetRefListSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedAnnotationSetSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedClassDataSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedCodeSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedStringDataSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedDebugInfoSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedAnnotationSectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedEncodedArraySectionOffset = this.buffer.readInt();</span><br><span class="line">        this.patchedAnnotationsDirectorySectionOffset = this.buffer.readInt();</span><br><span class="line">        this.oldDexSignature = this.buffer.readByteArray(SizeOf.SIGNATURE);</span><br><span class="line"></span><br><span class="line">        this.buffer.position(firstChunkOffset);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>构造函数中首先oldDex被封装为Dex对象，就是上面分析过的readHeader和readMap。不过patchFile是转化为一个DexPatchFile对象。首先将patch file读取为byte[]，然后调用其init方法，init方法首先判断MAGIC和Version，然后对patcheDexSize和各区域进行赋值，最后定位到数据区。</p>
<p>接下来的方法步骤较多，分为几个流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public DexPatchApplier(</span><br><span class="line">        Dex oldDexIn,</span><br><span class="line">        DexPatchFile patchFileIn</span><br><span class="line">) &#123;</span><br><span class="line">    this.oldDex = oldDexIn;</span><br><span class="line">    this.patchFile = patchFileIn;</span><br><span class="line">    //patchedDex作为最终输出的Dex对象</span><br><span class="line">    this.patchedDex = new Dex(patchFileIn.getPatchedDexSize());</span><br><span class="line">    this.oldToPatchedIndexMap = new SparseIndexMap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void executeAndSaveTo(File file) throws IOException &#123;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        os = new BufferedOutputStream(new FileOutputStream(file));</span><br><span class="line">            executeAndSaveTo(os);</span><br><span class="line">&#125;</span><br><span class="line">public void executeAndSaveTo(OutputStream out) throws IOException &#123;</span><br><span class="line">	// Firstly, set sections&apos; offset after patched, sort according to their offset so that</span><br><span class="line">        // the dex lib of aosp can calculate section size.</span><br><span class="line">        TableOfContents patchedToc = this.patchedDex.getTableOfContents();</span><br><span class="line"></span><br><span class="line">        patchedToc.header.off = 0;</span><br><span class="line">        patchedToc.header.size = 1;</span><br><span class="line">        patchedToc.mapList.size = 1;</span><br><span class="line"></span><br><span class="line">        patchedToc.stringIds.off</span><br><span class="line">                = this.patchFile.getPatchedStringIdSectionOffset();</span><br><span class="line">        patchedToc.typeIds.off</span><br><span class="line">                = this.patchFile.getPatchedTypeIdSectionOffset();</span><br><span class="line">        patchedToc.typeLists.off</span><br><span class="line">                = this.patchFile.getPatchedTypeListSectionOffset();</span><br><span class="line">        patchedToc.protoIds.off</span><br><span class="line">                = this.patchFile.getPatchedProtoIdSectionOffset();</span><br><span class="line">        patchedToc.fieldIds.off</span><br><span class="line">                = this.patchFile.getPatchedFieldIdSectionOffset();</span><br><span class="line">        patchedToc.methodIds.off</span><br><span class="line">                = this.patchFile.getPatchedMethodIdSectionOffset();</span><br><span class="line">        patchedToc.classDefs.off</span><br><span class="line">                = this.patchFile.getPatchedClassDefSectionOffset();</span><br><span class="line">        patchedToc.mapList.off</span><br><span class="line">                = this.patchFile.getPatchedMapListSectionOffset();</span><br><span class="line">        patchedToc.stringDatas.off</span><br><span class="line">                = this.patchFile.getPatchedStringDataSectionOffset();</span><br><span class="line">        patchedToc.annotations.off</span><br><span class="line">                = this.patchFile.getPatchedAnnotationSectionOffset();</span><br><span class="line">        patchedToc.annotationSets.off</span><br><span class="line">                = this.patchFile.getPatchedAnnotationSetSectionOffset();</span><br><span class="line">        patchedToc.annotationSetRefLists.off</span><br><span class="line">                = this.patchFile.getPatchedAnnotationSetRefListSectionOffset();</span><br><span class="line">        patchedToc.annotationsDirectories.off</span><br><span class="line">                = this.patchFile.getPatchedAnnotationsDirectorySectionOffset();</span><br><span class="line">        patchedToc.encodedArrays.off</span><br><span class="line">                = this.patchFile.getPatchedEncodedArraySectionOffset();</span><br><span class="line">        patchedToc.debugInfos.off</span><br><span class="line">                = this.patchFile.getPatchedDebugInfoSectionOffset();</span><br><span class="line">        patchedToc.codes.off</span><br><span class="line">                = this.patchFile.getPatchedCodeSectionOffset();</span><br><span class="line">        patchedToc.classDatas.off</span><br><span class="line">                = this.patchFile.getPatchedClassDataSectionOffset();</span><br><span class="line">        patchedToc.fileSize</span><br><span class="line">                = this.patchFile.getPatchedDexSize();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(patchedToc.sections);</span><br><span class="line">        patchedToc.computeSizesFromOffsets();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>1.这里读取patchFile中记录的值给patchedDex的TableOfContent中各种Section赋值，然后根据它们的偏移进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public void executeAndSaveTo(OutputStream out) throws IOException &#123;</span><br><span class="line">	// Secondly, run patch algorithms according to sections&apos; dependencies.</span><br><span class="line">        this.stringDataSectionPatchAlg = new StringDataSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.typeIdSectionPatchAlg = new TypeIdSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.protoIdSectionPatchAlg = new ProtoIdSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.fieldIdSectionPatchAlg = new FieldIdSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.methodIdSectionPatchAlg = new MethodIdSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.classDefSectionPatchAlg = new ClassDefSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.typeListSectionPatchAlg = new TypeListSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.annotationSetRefListSectionPatchAlg = new AnnotationSetRefListSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.annotationSetSectionPatchAlg = new AnnotationSetSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.classDataSectionPatchAlg = new ClassDataSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.codeSectionPatchAlg = new CodeSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.debugInfoSectionPatchAlg = new DebugInfoItemSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.annotationSectionPatchAlg = new AnnotationSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.encodedArraySectionPatchAlg = new StaticValueSectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line">        this.annotationsDirectorySectionPatchAlg = new AnnotationsDirectorySectionPatchAlgorithm(</span><br><span class="line">                patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        this.stringDataSectionPatchAlg.execute();</span><br><span class="line">        this.typeIdSectionPatchAlg.execute();</span><br><span class="line">        this.typeListSectionPatchAlg.execute();</span><br><span class="line">        this.protoIdSectionPatchAlg.execute();</span><br><span class="line">        this.fieldIdSectionPatchAlg.execute();</span><br><span class="line">        this.methodIdSectionPatchAlg.execute();</span><br><span class="line">        this.annotationSectionPatchAlg.execute();</span><br><span class="line">        this.annotationSetSectionPatchAlg.execute();</span><br><span class="line">        this.annotationSetRefListSectionPatchAlg.execute();</span><br><span class="line">        this.annotationsDirectorySectionPatchAlg.execute();</span><br><span class="line">        this.debugInfoSectionPatchAlg.execute();</span><br><span class="line">        this.codeSectionPatchAlg.execute();</span><br><span class="line">        this.classDataSectionPatchAlg.execute();</span><br><span class="line">        this.encodedArraySectionPatchAlg.execute();</span><br><span class="line">        this.classDefSectionPatchAlg.execute();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>2.这里初始化了很多算法，依次调用execute()方法。这里依旧来看stringDataSectionPatchAlg的execute方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void execute() &#123;</span><br><span class="line">    final int deletedItemCount = patchFile.getBuffer().readUleb128();</span><br><span class="line">    final int[] deletedIndices = readDeltaIndiciesOrOffsets(deletedItemCount);</span><br><span class="line"></span><br><span class="line">    final int addedItemCount = patchFile.getBuffer().readUleb128();</span><br><span class="line">    final int[] addedIndices = readDeltaIndiciesOrOffsets(addedItemCount);</span><br><span class="line"></span><br><span class="line">    final int replacedItemCount = patchFile.getBuffer().readUleb128();</span><br><span class="line">    final int[] replacedIndices = readDeltaIndiciesOrOffsets(replacedItemCount);</span><br><span class="line"></span><br><span class="line">    final TableOfContents.Section tocSec = getTocSection(this.oldDex);</span><br><span class="line">    Dex.Section oldSection = null;</span><br><span class="line"></span><br><span class="line">    int oldItemCount = 0;</span><br><span class="line">    if (tocSec.exists()) &#123;</span><br><span class="line">        oldSection = this.oldDex.openSection(tocSec);</span><br><span class="line">        oldItemCount = tocSec.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Now rest data are added and replaced items arranged in the order of</span><br><span class="line">    // added indices and replaced indices.</span><br><span class="line">    doFullPatch(</span><br><span class="line">            oldSection, oldItemCount, deletedIndices, addedIndices, replacedIndices</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里1.读取del的数量，将index存储在int数组中。2.读取add的数量，将index存储在int数组中。3.读取replace的数量，将index存储在int数组中。</p>
<p>然后就拿着deletedIndices,addedIndices,replacedIndices,oldSection, oldItemCount就能进行完整的patch了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private void doFullPatch(</span><br><span class="line">        Dex.Section oldSection,</span><br><span class="line">        int oldItemCount,</span><br><span class="line">        int[] deletedIndices,</span><br><span class="line">        int[] addedIndices,</span><br><span class="line">        int[] replacedIndices</span><br><span class="line">) &#123;</span><br><span class="line">    int deletedItemCount = deletedIndices.length;</span><br><span class="line">    int addedItemCount = addedIndices.length;</span><br><span class="line">    int replacedItemCount = replacedIndices.length;</span><br><span class="line">    int newItemCount = oldItemCount + addedItemCount - deletedItemCount;</span><br><span class="line"></span><br><span class="line">    int deletedItemCounter = 0;</span><br><span class="line">    int addActionCursor = 0;</span><br><span class="line">    int replaceActionCursor = 0;</span><br><span class="line"></span><br><span class="line">    int oldIndex = 0;</span><br><span class="line">    int patchedIndex = 0;</span><br><span class="line">    while (oldIndex &lt; oldItemCount || patchedIndex &lt; newItemCount) &#123;</span><br><span class="line">        if (addActionCursor &lt; addedItemCount &amp;&amp; addedIndices[addActionCursor] == patchedIndex) &#123;</span><br><span class="line">            T addedItem = nextItem(patchFile.getBuffer());</span><br><span class="line">            int patchedOffset = writePatchedItem(addedItem);</span><br><span class="line">            ++addActionCursor;</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (replaceActionCursor &lt; replacedItemCount &amp;&amp; replacedIndices[replaceActionCursor] == patchedIndex) &#123;</span><br><span class="line">            T replacedItem = nextItem(patchFile.getBuffer());</span><br><span class="line">            int patchedOffset = writePatchedItem(replacedItem);</span><br><span class="line">            ++replaceActionCursor;</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (Arrays.binarySearch(deletedIndices, oldIndex) &gt;= 0) &#123;</span><br><span class="line">            T skippedOldItem = nextItem(oldSection); // skip old item.</span><br><span class="line">            markDeletedIndexOrOffset(</span><br><span class="line">                    oldToPatchedIndexMap,</span><br><span class="line">                    oldIndex,</span><br><span class="line">                    getItemOffsetOrIndex(oldIndex, skippedOldItem)</span><br><span class="line">            );</span><br><span class="line">            ++oldIndex;</span><br><span class="line">            ++deletedItemCounter;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (Arrays.binarySearch(replacedIndices, oldIndex) &gt;= 0) &#123;</span><br><span class="line">            T skippedOldItem = nextItem(oldSection); // skip old item.</span><br><span class="line">            markDeletedIndexOrOffset(</span><br><span class="line">                    oldToPatchedIndexMap,</span><br><span class="line">                    oldIndex,</span><br><span class="line">                    getItemOffsetOrIndex(oldIndex, skippedOldItem)</span><br><span class="line">            );</span><br><span class="line">            ++oldIndex;</span><br><span class="line">        &#125; else</span><br><span class="line">        if (oldIndex &lt; oldItemCount) &#123;</span><br><span class="line">            T oldItem = adjustItem(this.oldToPatchedIndexMap, nextItem(oldSection));</span><br><span class="line"></span><br><span class="line">            int patchedOffset = writePatchedItem(oldItem);</span><br><span class="line"></span><br><span class="line">            updateIndexOrOffset(</span><br><span class="line">                    this.oldToPatchedIndexMap,</span><br><span class="line">                    oldIndex,</span><br><span class="line">                    getItemOffsetOrIndex(oldIndex, oldItem),</span><br><span class="line">                    patchedIndex,</span><br><span class="line">                    patchedOffset</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            ++oldIndex;</span><br><span class="line">            ++patchedIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是往patchedDex的stringData区写数据，写入的数据就包含：1.新增的数据。2.替代的数据。3.oldDex中除去新增和被替代的数据。</p>
<p>所以计算得到的int newItemCount = oldItemCount + addedItemCount - deletedItemCount;然后开始遍历，写入对应的item。对应的Item写入代码就包含：1.判断该patchIndex是否包含在addedIndices中，如果包含则写入；2.判断是否在replacedIndices中，如果包含则写入；3.如果在oldIndex被delete或者replace，直接跳过；4.如果是oldIndex非delete和replace的，也就是和newDex中items相同的部分。</p>
<p>1.2.4三个部分即可组成完整的newDex的该区域。这样就完成了stringData区域的patch算法，其他的14个算法的execute代码是相同的，都会完成各个部分的patch算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void executeAndSaveTo(OutputStream out) throws IOException &#123;</span><br><span class="line">// Thirdly, write header, mapList. Calculate and write patched dex&apos;s sign and checksum.</span><br><span class="line">        Dex.Section headerOut = this.patchedDex.openSection(patchedToc.header.off);</span><br><span class="line">        patchedToc.writeHeader(headerOut);</span><br><span class="line"></span><br><span class="line">        Dex.Section mapListOut = this.patchedDex.openSection(patchedToc.mapList.off);</span><br><span class="line">        patchedToc.writeMap(mapListOut);</span><br><span class="line"></span><br><span class="line">        this.patchedDex.writeHashes();</span><br><span class="line"></span><br><span class="line">        // Finally, write patched dex to file.</span><br><span class="line">        this.patchedDex.writeTo(out);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后一个步骤就是写header，mapList的数据。这样就完成了完整的dex的恢复，最后将内存中的所有数据写到文件中。</p>
<h5 id="补丁合成的原理"><a href="#补丁合成的原理" class="headerlink" title="补丁合成的原理"></a>补丁合成的原理</h5><p>前面我们已经生成了补丁包，接着通过服务器下发或者本地放入sd卡中，通过应用启动之后进行加载合成。这一节中就来讲这个具体的过程。</p>
<p>程序启动时会加载默认的Application类，将导致无法对它进行补丁修复。Tinker中为了避免这个问题，是通过将原来的Application类隔离起来，将Application类以及它的继承类的所有代码移至自己的ApplicationLike继承类中。并且把attachBaseContext方法实现单独移动到onBaseContextAttached中，这里的onBaseContextAttached并不是Application的生命周期，这个方法是在自己生成的TinkerApplication中的attachBaseContext方法中调用的，这里这样处理的目的就是为了将Application类隔离起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">@DefaultLifeCycle(application = &quot;tinker.sample.android.app.SampleApplication&quot;,</span><br><span class="line">                  flags = ShareConstants.TINKER_ENABLE_ALL,</span><br><span class="line">                  loadVerifyFlag = false)</span><br><span class="line">public class SampleApplicationLike extends DefaultApplicationLike &#123;</span><br><span class="line">    private static final String TAG = &quot;Tinker.SampleApplicationLike&quot;;</span><br><span class="line"></span><br><span class="line">    public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</span><br><span class="line">                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</span><br><span class="line">        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里通过注解生成我们真正的application类:SampleApplication.而DefaultApplicationLike是我们的代理类。这里看TinkerApplication类的实现可以看出这里用的是代理模式。</p>
<p>这里重点看TinkerApplication中的方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void onBaseContextAttached(Context base) &#123;</span><br><span class="line">    loadTinker();</span><br><span class="line">    applicationLike.onBaseContextAttached(base);</span><br><span class="line">&#125;</span><br><span class="line">private void loadTinker() &#123;</span><br><span class="line">        //reflect tinker loader, because loaderClass may be define by user!</span><br><span class="line">            Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());</span><br><span class="line"></span><br><span class="line">            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);</span><br><span class="line">            Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</span><br><span class="line">            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里通过传入的loader类，通过反射调用tryLoad方法，这里的loader类默认是TinkerLoader，这里内部会调用到tryLoadPatchFilesInternal，会判断是否开启dex修复，lib修复，资源修复，然后再分别调用TinkerDexLoader,TinkerResourceLoader等方法进行对应的修复，这里我们看dex修复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SampleApplication extends TinkerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public SampleApplication() &#123;</span><br><span class="line">        super(7, &quot;tinker.sample.android.app.SampleApplicationLike&quot;, &quot;com.tencent.tinker.loader.TinkerLoader&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TinkerLoader extends AbstractTinkerLoader &#123;</span><br><span class="line">	@Override</span><br><span class="line">    public Intent tryLoad(TinkerApplication app) &#123;</span><br><span class="line">        tryLoadPatchFilesInternal(app, resultIntent);</span><br><span class="line">        return resultIntent;</span><br><span class="line">    &#125;</span><br><span class="line">    private void tryLoadPatchFilesInternal(TinkerApplication app, Intent resultIntent) &#123;</span><br><span class="line">    ...</span><br><span class="line">    	boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);</span><br><span class="line">    	boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);</span><br><span class="line">    ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>第一步，先调用checkComplete方法从assets/dex_meta.txt中检查记录的dex信息，检查对应的dex文件是否存在，并保存到loadDexList中。</p>
<p>第二部调用TinkerDexLoader.loadTinkerJars方法会首先根据是否支持dalvik或者art做对应的处理，最后调用installDexes方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SystemClassLoaderAdder &#123;</span><br><span class="line">	@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">    public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List&lt;File&gt; files)</span><br><span class="line">        throws Throwable &#123;</span><br><span class="line">        Log.i(TAG, &quot;installDexes dexOptDir: &quot; + dexOptDir.getAbsolutePath() + &quot;, dex size:&quot; + files.size());</span><br><span class="line"></span><br><span class="line">        if (!files.isEmpty()) &#123;</span><br><span class="line">            files = createSortedAdditionalPathEntries(files);</span><br><span class="line">            ClassLoader classLoader = loader;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;= 24 &amp;&amp; !checkIsProtectedApp(files)) &#123;</span><br><span class="line">                classLoader = AndroidNClassLoader.inject(loader, application);</span><br><span class="line">            &#125;</span><br><span class="line">            //because in dalvik, if inner class is not the same classloader with it wrapper class.</span><br><span class="line">            //it won&apos;t fail at dex2opt</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">                V23.install(classLoader, files, dexOptDir);</span><br><span class="line">            &#125; else if (Build.VERSION.SDK_INT &gt;= 19) &#123;</span><br><span class="line">                V19.install(classLoader, files, dexOptDir);</span><br><span class="line">            &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</span><br><span class="line">                V14.install(classLoader, files, dexOptDir);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                V4.install(classLoader, files, dexOptDir);</span><br><span class="line">            &#125;</span><br><span class="line">            //install done</span><br><span class="line">            sPatchDexCount = files.size();</span><br><span class="line">            Log.i(TAG, &quot;after loaded classloader: &quot; + classLoader + &quot;, dex size:&quot; + sPatchDexCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>这里根据不同的系统版本，反射处理dexElements。看一下最新版本的SDK实现，就是V23.install方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static final class V23 &#123;</span><br><span class="line">	private static void install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">                                    File optimizedDirectory)</span><br><span class="line">            throws IllegalArgumentException, IllegalAccessException,</span><br><span class="line">            NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException &#123;</span><br><span class="line">            /* The patched class loader is expected to be a descendant of</span><br><span class="line">             * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">             * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">             * file entries.</span><br><span class="line">             */</span><br><span class="line">            Field pathListField = ShareReflectUtil.findField(loader, &quot;pathList&quot;);</span><br><span class="line">            Object dexPathList = pathListField.get(loader);</span><br><span class="line">            ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">            ShareReflectUtil.expandFieldArray(dexPathList, &quot;dexElements&quot;, makePathElements(dexPathList,</span><br><span class="line">                new ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                suppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>1.拿到PathClassLoader对象中的pathList字段</p>
<p>2.根据pathList对象找到makePathElements方法，返回Element[]数组</p>
<p>3.拿到pathList对象中原本的dexElements对象</p>
<p>4.将步骤2和步骤3中的Element[]数组合并，将patch相关的dex放在数组前面</p>
<p>5.最后将合并后的数组，设置给pathList。</p>
<p><strong>合成补丁</strong></p>
<p>在sample中是在点击Button的时候调用TinkerInstaller.onReceiveUpgradePatch(Context context, String patchLocation)方法来加载补丁，其流程如下：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\tinker打补丁包基础流程.png" alt="tinker打补丁包基础流程"></p>
<p>1-5：加载补丁文件</p>
<p>6-9：启动一个JobSeheduler来处理任务</p>
<p>10-13：启动一个AsyncTask在执行补丁包合成的任务</p>
<p>14-18：补丁包合成的核心流程，补丁包的验证，dex修复，lib修复，res修复等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,</span><br><span class="line">                                            String patchVersionDirectory, File patchFile) &#123;</span><br><span class="line">    String dexMeta = checker.getMetaContentMap().get(DEX_META_FILE)；</span><br><span class="line">    </span><br><span class="line">    boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, final File patchFile) &#123;</span><br><span class="line">        String dir = patchVersionDirectory + &quot;/&quot; + DEX_PATH + &quot;/&quot;;</span><br><span class="line"></span><br><span class="line">        if (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) &#123;</span><br><span class="line">            TinkerLog.w(TAG, &quot;patch recover, extractDiffInternals fail&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File dexFiles = new File(dir);</span><br><span class="line">        File[] files = dexFiles.listFiles();</span><br><span class="line">        List&lt;File&gt; legalFiles = new ArrayList&lt;&gt;();</span><br><span class="line">        // may have directory in android o</span><br><span class="line">        if (files != null) &#123;</span><br><span class="line">            for (File file : files) &#123;</span><br><span class="line">                if (file.isFile()) &#123;</span><br><span class="line">                    legalFiles.add(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String optimizeDexDirectory = patchVersionDirectory + &quot;/&quot; + DEX_OPTIMIZE_PATH + &quot;/&quot;;</span><br><span class="line">        return dexOptimizeDexFiles(context, legalFiles, optimizeDexDirectory, patchFile);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static boolean extractDexDiffInternals(Context context, String dir, String meta, File patchFile, int type) &#123;</span><br><span class="line">        //parse</span><br><span class="line">        patchList.clear();</span><br><span class="line">        ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, patchList);</span><br><span class="line"></span><br><span class="line">        File directory = new File(dir);</span><br><span class="line">        if (!directory.exists()) &#123;</span><br><span class="line">            directory.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        //I think it is better to extract the raw files from apk</span><br><span class="line">        Tinker manager = Tinker.with(context);</span><br><span class="line">        ZipFile apk = null;</span><br><span class="line">        ZipFile patch = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ApplicationInfo applicationInfo = context.getApplicationInfo();</span><br><span class="line"></span><br><span class="line">            String apkPath = applicationInfo.sourceDir;</span><br><span class="line">            apk = new ZipFile(apkPath);</span><br><span class="line">            patch = new ZipFile(patchFile);</span><br><span class="line">            </span><br><span class="line">            for (ShareDexDiffPatchInfo info : patchList) &#123;</span><br><span class="line">                long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                final String infoPath = info.path;</span><br><span class="line">                String patchRealPath;</span><br><span class="line">                if (infoPath.equals(&quot;&quot;)) &#123;</span><br><span class="line">                    patchRealPath = info.rawName;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    patchRealPath = info.path + &quot;/&quot; + info.rawName;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String dexDiffMd5 = info.dexDiffMd5;</span><br><span class="line">                String oldDexCrc = info.oldDexCrC;</span><br><span class="line"></span><br><span class="line">                if (!isVmArt &amp;&amp; info.destMd5InDvm.equals(&quot;0&quot;)) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, &quot;patch dex %s is only for art, just continue&quot;, patchRealPath);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                String extractedFileMd5 = isVmArt ? info.destMd5InArt : info.destMd5InDvm;</span><br><span class="line"></span><br><span class="line">                File extractedFile = new File(dir + info.realName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                ZipEntry patchFileEntry = patch.getEntry(patchRealPath);</span><br><span class="line">                ZipEntry rawApkFileEntry = apk.getEntry(patchRealPath);</span><br><span class="line"></span><br><span class="line">                if (oldDexCrc.equals(&quot;0&quot;)) &#123;</span><br><span class="line">                    if (patchFileEntry == null) &#123;</span><br><span class="line">                        TinkerLog.w(TAG, &quot;patch entry is null. path:&quot; + patchRealPath);</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //it is a new file, but maybe we need to repack the dex file</span><br><span class="line">                    if (!extractDexFile(patch, patchFileEntry, extractedFile, info)) &#123;</span><br><span class="line">                        TinkerLog.w(TAG, &quot;Failed to extract raw patch file &quot; + extractedFile.getPath());</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (dexDiffMd5.equals(&quot;0&quot;)) &#123;</span><br><span class="line">                    //check source crc instead of md5 for faster</span><br><span class="line">                    String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());</span><br><span class="line">                    if (!rawEntryCrc.equals(oldDexCrc)) &#123;</span><br><span class="line">                        TinkerLog.e(TAG, &quot;apk entry %s crc is not equal, expect crc: %s, got crc: %s&quot;, patchRealPath, oldDexCrc, rawEntryCrc);</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Small patched dex generating strategy was disabled, we copy full original dex directly now.</span><br><span class="line">                    //patchDexFile(apk, patch, rawApkFileEntry, null, info, smallPatchInfoFile, extractedFile);</span><br><span class="line">                    extractDexFile(apk, rawApkFileEntry, extractedFile, info);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //check source crc instead of md5 for faster</span><br><span class="line">                    String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());</span><br><span class="line">                    if (!rawEntryCrc.equals(oldDexCrc)) &#123;</span><br><span class="line">                        TinkerLog.e(TAG, &quot;apk entry %s crc is not equal, expect crc: %s, got crc: %s&quot;, patchRealPath, oldDexCrc, rawEntryCrc);</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    patchDexFile(apk, patch, rawApkFileEntry, patchFileEntry, info, extractedFile);</span><br><span class="line"></span><br><span class="line">                    if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) &#123;</span><br><span class="line">                        TinkerLog.w(TAG, &quot;Failed to recover dex file when verify patched dex: &quot; + extractedFile.getPath());</span><br><span class="line">                        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                        SharePatchFileUtil.safeDeleteFile(extractedFile);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    TinkerLog.w(TAG, &quot;success recover dex file: %s, size: %d, use time: %d&quot;,</span><br><span class="line">                        extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mergeClassNDexFiles(context, patchFile, dir)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new TinkerRuntimeException(&quot;patch &quot; + ShareTinkerInternals.getTypeString(type) + &quot; extract failed (&quot; + e.getMessage() + &quot;).&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            SharePatchFileUtil.closeZip(apk);</span><br><span class="line">            SharePatchFileUtil.closeZip(patch);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先解析meta中的信息，meta中包含了patch中每个dex的相关数据。然后拿到apk和patch的文件路径，根据文件信息进行crc校验和md5校验，然后调用patchDexFile对两个dex文件合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void patchDexFile(</span><br><span class="line">    ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,</span><br><span class="line">    ShareDexDiffPatchInfo patchInfo, File patchedDexFile) throws IOException &#123;</span><br><span class="line">    InputStream oldDexStream = null;</span><br><span class="line">    InputStream patchFileStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        oldDexStream = new BufferedInputStream(baseApk.getInputStream(oldDexEntry));</span><br><span class="line">        patchFileStream = (patchFileEntry != null ? new BufferedInputStream(patchPkg.getInputStream(patchFileEntry)) : null);</span><br><span class="line">        </span><br><span class="line">        zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(patchedDexFile)));</span><br><span class="line">                    zos.putNextEntry(new ZipEntry(ShareConstants.DEX_IN_JAR));</span><br><span class="line">                    new DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(zos);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>通过ZipFile拿到文件流，读取本地apk中的dex文件和patch中的dex文件，然后通过executeAndSaveTo合并到最终的patchedDexFile，也就是上面所说的生成差分包的原理。</p>
<h5 id="具体案例分析"><a href="#具体案例分析" class="headerlink" title="具体案例分析"></a>具体案例分析</h5><p>我分别编写了2个java文件，Hello.java和World.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;hello dex!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class World&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;nani World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hello.dex和World.dex结构分别如下：</p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\Hello.dex结构.jpg" alt="Hello.dex结构"></p>
<p><img src="C:\Users\peyo\Desktop\图片资料\tinker接入实践\tinker原理解析\World.dex结构.jpg" alt="World.dex结构"></p>
<p>按照之前的diff算法，得到以下操作：</p>
<p>del 1 </p>
<p>del 2 </p>
<p>add 1 LWorld;</p>
<p>add 8 World.java</p>
<p>del 10 </p>
<p>add 11 nani World</p>
<p>然后根据索引排序：</p>
<p>del 1 </p>
<p>add 1 LWorld;</p>
<p>del 2 </p>
<p>add 8 World.java</p>
<p>del 10 </p>
<p>add 11 nani World</p>
<p>将index一致且DEL和ADD相邻的操作替换为replace:</p>
<p>replace 1 LWorld</p>
<p>del 2</p>
<p>add 8 World.java</p>
<p>del 10 </p>
<p>add 11 nani World</p>
<p>在write时，按照DEL,ADD,REPLACE进行分类，并将出现的item放置到newItemList：</p>
<p>del ops:</p>
<p>​    del 2</p>
<p>​    del 10</p>
<p>add ops:</p>
<p>​    add 8</p>
<p>​    add 11</p>
<p>replace ops:</p>
<p>​    1</p>
<p>newItemList为：</p>
<p>LWorld //replace 1</p>
<p>World.java //add8</p>
<p>naniWorld //add11</p>
<p>然后写入，写入的顺序为：</p>
<p>2 //del size</p>
<p>2</p>
<p>8 //index - lastIndex</p>
<p>2 //add size</p>
<p>8</p>
<p>3 // index - lastIndex</p>
<p>1 //replace size</p>
<p>1</p>
<p>LWorld</p>
<p>World.java</p>
<p>naniWorld</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/lmj623565791/article/details/60874334#t6" target="_blank" rel="noopener">Android 热修复 Tinker 源码分析之DexDiff / DexPatch</a></p>
<p><a href="https://www.zybuluo.com/dodola/note/554061" target="_blank" rel="noopener">Tinker</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://youuupeng.github.io/2019/01/28/热修复方案对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youpeng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/热修复方案对比/" itemprop="url">热修复方案对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-28T13:49:34+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="热修复方案对比"><a href="#热修复方案对比" class="headerlink" title="热修复方案对比"></a>热修复方案对比</h1><h3 id="热修复简介"><a href="#热修复简介" class="headerlink" title="热修复简介"></a>热修复简介</h3><p><strong>正常开发流程</strong></p>
<p><img src="https://s2.ax1x.com/2019/01/14/Fx1DED.png" alt="正常开发流程">需要用户主动去下载更新app，修复时间较长。apk文件大。</p>
<p><strong>热修复开发流程</strong></p>
<p><img src="https://s2.ax1x.com/2019/01/14/Fx1du6.png" alt="热修复开发流程"></p>
<p>只要打开app就能自动更新。补丁包小。快速修复bug。</p>
<h3 id="冷启动代码修复方案"><a href="#冷启动代码修复方案" class="headerlink" title="冷启动代码修复方案"></a>冷启动代码修复方案</h3><h4 id="腾讯系"><a href="#腾讯系" class="headerlink" title="腾讯系"></a>腾讯系</h4><p><img src="https://s2.ax1x.com/2019/01/14/Fx1Ujx.png" alt="腾讯系热修复方案"></p>
<h5 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a>Tinker</h5><ul>
<li>原理</li>
</ul>
<p>一个ClassLoadere可以包含多个dex文件，每个dex文件是一个Element，多个dex文件排列成一个有序的数组dexElements，当查找类的时候，按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找到类则返回，如果找不到从下一个dex文件继续查找。因此，通过把有问题的类修复之后打包到一个dex中，然后把这个dex插入到Elements的最前面就可以实现类的替换，从而解决这个类的bug。</p>
<p>Tinker提供dex差量包patch.dex的形式，然后将patch.dex与原应用的classes.dex合并成一个完整的dex，完整dex加载得到的dexFile对象作为参数构建一个Element对象然后整体替换掉旧的dexElements数组。</p>
<ul>
<li>优点</li>
</ul>
<p>极致的dex补丁差量操作。生成的补丁包时比较粒度十分精细，实现了代码级别的差异比较，而不是传统的BsDiff算法。合成的时候也是根据补丁和原有的apk的dex进行精细的合成操作。</p>
<ul>
<li>缺陷</li>
</ul>
<p>1.由于其精细合成的问题在于性能损耗，dex合成是在一个单独的进程中进行的。dex merge操作是在java heap上进行的，如果此时进程申请的java heap对象超过了vm heap规定的大小，进程OOM，memory killer可能会杀掉该进程，导致dex合成失败。</p>
<p>打补丁包的成功取决于合成操作的成功率。</p>
<ul>
<li><p>已知问题</p>
<p>1.在AndroidN上，补丁对应用启动时间有轻微的影响。</p>
<p>2.不支持一些操作系统是android-21的部分三星手机，加载补丁时会主动抛出”TinkerRuntimeException:checkDexInstall failed”</p>
<p>3.对于资源替换，不支持remoteView.例如transition动画，notification icon以及桌面图标。</p>
</li>
</ul>
<h4 id="Amigo"><a href="#Amigo" class="headerlink" title="Amigo"></a>Amigo</h4><ul>
<li>核心实现</li>
</ul>
<p>主要介绍一下Amigo和其他方案的不同点，以及其实现原理。</p>
<ul>
<li>修复class</li>
</ul>
<p>上边说到腾讯系的方案是反射操作DexPathList中的dexElements。Amigo的补丁包是一个完整全新的apk，解压dex后，先对所有的dex文件进行dexopt/dex2oat操作，然后重新构建一个ClassLoader。其目的是为了1：加快启动的速度。2.不需要大量的反射处理提升了兼容性。</p>
<ul>
<li>增加四大组件</li>
</ul>
<p>Amigo同其他方案的区别在于能够增加四大组件。其实现方式其实就是类似插件化的原理，因为其补丁包是apk的形式，Activity通过hook加载流程，打开对应launch mode的StubActivity，再反射注入新Activity的实例;Service、Provider也是通过ServiceStub、ProviderStub实现；BroadcastReceiver是变静态注册为动态注册实现的。</p>
<p>以Activity的启动时序为例，标注出其中的hook点：</p>
<ul>
<li><img src="https://s2.ax1x.com/2019/01/14/Fx10HO.png" alt="activity hook">差分实现</li>
</ul>
<p>一般情况下，是通过下发完整的apk，但是如果全量下发会存在下发成功率的问题。因此在Amigo可以自己实现差分算法，Amigo也提供了基于APK内部细粒度的ZipPatch，也可以自己选择GooglePlay上的archive-patcher，也可以是自己实现的差分算法。</p>
<h5 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h5><ul>
<li><p>不支持和Instant Run同时使用</p>
</li>
<li><p>Amigo的实现是通过单一ClassLoader、单一AssetManager的app，在一些多classloader的插件化框架中可能不兼容</p>
</li>
<li><p>RemoteViews的自定义布局不支持修改，只支持内容修复</p>
</li>
<li><p>Amigo相对于其他方案来说，其能够实现四大组件的增加。</p>
</li>
<li><p>其最大的缺陷在于补丁包是一个完成的apk，对于大一点的app很大程度上限制的下发成功率。以及其差分粒度是不如DexDiff。</p>
<h5 id="使用风险"><a href="#使用风险" class="headerlink" title="使用风险"></a>使用风险</h5><ul>
<li><p>后台服务Amigo平台已不再支持Amigo服务</p>
</li>
<li><p>随着amigo的核心人员去了阿里和其他公司，两三年前已停止维护</p>
</li>
</ul>
</li>
</ul>
<h3 id="热替换代码修复-amp-amp-冷启动代码修复"><a href="#热替换代码修复-amp-amp-冷启动代码修复" class="headerlink" title="热替换代码修复 &amp;&amp; 冷启动代码修复"></a>热替换代码修复 &amp;&amp; 冷启动代码修复</h3><h5 id="阿里系"><a href="#阿里系" class="headerlink" title="阿里系"></a>阿里系</h5><p><img src="https://s2.ax1x.com/2019/01/14/Fx1wDK.png" alt="阿里系热修复方案"></p>
<p>Sophix方案是同时支持即时生效和冷启动修复</p>
<h6 id="热替换代码修复原理"><a href="#热替换代码修复原理" class="headerlink" title="热替换代码修复原理"></a>热替换代码修复原理</h6><p>在旧的热替换方案Andfix方案中，是通过直接在已经加载的类中的native层替换掉原有方法，是在原有类的基础上进行修改的。每一个Java方法在Art虚拟机中对应着一个ArtMethod，ArtMethod中记录了这个Java方法的所有信息，包括所属类、访问权限，代码执行地址等。因此通过构造一个新的ArtMethod，将其所有字段替换掉原有ArtMethod的所有字段，可以实现代码的替换。</p>
<p>但是由于各手机厂商是能够对ArtMethod结构体进行修改，如果对其进行了修改，就和原有开源代码里的结构不一致，那么这种替换机制就会出问题。因此，这种方案的最大的问题就在于依赖于ArtMethod等ROM底层方法结构而导致的兼容性问题，在一些修改了底层的虚拟机结构的机器就无法支持。</p>
<p>在Sophix中将原有所有字段逐一替换的方式改成了通过在底层memcpy的方法来完整替换ArtMethod。只要像这样把ArtMethod整个结构体完整替换，就能够把所有旧方法成员自动对应的换成新方法的成员。</p>
<h6 id="冷启动修复原理"><a href="#冷启动修复原理" class="headerlink" title="冷启动修复原理"></a>冷启动修复原理</h6><p>上边说到腾讯系的热修复原理是通过把原有的dex和补丁包里的dex重新合成一个。Sophix的冷启动修复思想是把原先基线包里的dex中，去掉补丁中也有的类。这样，补丁+去除了补丁类的基线包就等于新App中的所有类。不过它不是真正的去掉基线包中的类，而是移除定义类的入口，对于类的具体内容不进行删除。</p>
<h6 id="热替换修复的优缺点"><a href="#热替换修复的优缺点" class="headerlink" title="热替换修复的优缺点"></a>热替换修复的优缺点</h6><p>优点：热替换方式的修复无需重启可以直接生效，这种方式修复实时性更高。</p>
<p>缺点：由于是在应用运行期间发生了变动，如果修改了某个方法的逻辑，就会导致它在修复前后的逻辑不一致，引发一些诡异的错误。因此热替换方式的热修复只适用于修复一些简单的BUG，如果要做一些功能方面的更新，不建议采用。</p>
<h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><table>
<thead>
<tr>
<th></th>
<th>Tinker</th>
<th>Sophix</th>
<th>Amigo</th>
</tr>
</thead>
<tbody>
<tr>
<td>类替换</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>lib替换</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>资源替换</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>全平台支持</td>
<td>yes</td>
<td>yes</td>
<td>2.1-7.1</td>
</tr>
<tr>
<td>即时生效</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>性能损耗</td>
<td>中,有合成操作</td>
<td>低，冷启动下有些损耗</td>
<td>低</td>
</tr>
<tr>
<td>补丁包大小</td>
<td>小</td>
<td>小</td>
<td>大</td>
</tr>
</tbody>
</table>
<h3 id="热补丁的更新方式"><a href="#热补丁的更新方式" class="headerlink" title="热补丁的更新方式"></a>热补丁的更新方式</h3><p>1.pull通道，在登录的时候通过pull查询后台是否有对应的补丁包更新，这也是最常用的方式。这还需要后台搭建，提供补丁后台托管，版本管理，保证传输安全，管理历史记录，监控补丁的运行情况等。</p>
<p>2.指定版本的push通道</p>
<p>Tinker的有<a href="http://www.tinkerpatch.com/" target="_blank" rel="noopener">TinkerPatch</a>，不过它也是<a href="http://www.tinkerpatch.com/Price" target="_blank" rel="noopener">收费</a>的,可以针对我们的用户量来考虑是否使用。支持补丁下发，版本管理，补丁回退等功能。如果采用Tinker方案可以先考虑接入TinkerPatch。</p>
<h3 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h3><p>1.主流的热修复框架Tinker，Sophix在最新的版本也支持了新增Activity，不过方式跟组件化一样，需要提前在原有AndroidManifest.xml文件中插桩实现。</p>
<p>2.由于GooglePlay开发者条款协议，不建议在GooglePlay平台动态更新代码</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比主流的Tinker方案和Sophix方案，性能相差并不太多。但由于Sophix是按照用户量<a href="https://help.aliyun.com/document_detail/57064.html?spm=5176.131995.673114.price_desc_pc.7cbd69fdXYV7DM" target="_blank" rel="noopener">收费</a>的，其接入成本，维护自然会容易些，而且有配套的服务后端。不过考虑虽然可能我们的app现在的用户量会少一点，不过考虑到后期可能的流量增加，其收费也是较高的。而且其具有的热替换代码修复也是有局限性，优势并不大。而对于其他框架Amigo来说，它的优势在于能够添加四大组件，不过考虑到热修复应该只能作为紧急修复线上严重问题时的补救措施，其核心在于下发的成功率和稳定性，对于添加组件的功能倒是其次。而且随着Amigo两三年前停止维护，其稳定性和新版本的兼容也是不够的。综上，可以考虑Tinker的方案来进行热修复的接入。</p>
<p>最后，热修复作为一个临时解决线上问题的一个解决方案，我们应该尽量避免使用它们，应该尽量提高正常迭代版本的稳定性，以及合理的迭代周期，而不是太过于依赖热修复这种线上解决问题的这种方式。</p>
<h3 id="参考-amp-amp-扩展阅读"><a href="#参考-amp-amp-扩展阅读" class="headerlink" title="参考 &amp;&amp; 扩展阅读"></a>参考 &amp;&amp; 扩展阅读</h3><p><a href="http://product.dangdang.com/25328008.html" target="_blank" rel="noopener">《深入探索Android热修复技术原理》</a></p>
<p><a href="https://github.com/Tencent/tinker/wiki" target="_blank" rel="noopener">Tinker</a></p>
<p><a href="https://github.com/eleme/Amigo" target="_blank" rel="noopener">Amigo</a></p>
<p><a href="https://www.zybuluo.com/dodola/note/554061" target="_blank" rel="noopener">Tinker Dexdiff算法解析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">youpeng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/youuupeng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youpeng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
